{"./":{"url":"./","title":"目录","keywords":"","body":"目录 Linux Linux常用命令 计算机基础 数据结构 算法模板 技能树 阅读笔记 Git 踩坑 Docker 工具 Kafka Java 基础 SpringBoot+Vue开发实战笔记 Chapter01 Chapter02 Chapter03 Chapter04 Chapter05 Chapter06 Chapter07 Chapter08 Chapter09 Chapter10 Chapter11 Chapter12 Chapter13 代码段 Python Python基础 数据库 前端 HTML 数据库 HiveSQL MySQL Redis "},"Linux/常用命令.html":{"url":"Linux/常用命令.html","title":"Linux常用命令","keywords":"","body":"Linux常用命令 查看指定端口的进程 netstat -ano|findstr 8080 终端 sockte 命令 [nc -lk 9000] 查看 Linux 内核版本命令 cat /proc/version uname -a 查看 Linux 系统版本的命令 lsb_release -a 这个命令适用于所有的Linux发行版，包括Redhat、SuSE、Debian…等发行版。 cat /etc/redhat-release 这种方法只适合Redhat系的Linux： cat /etc/issue 此命令也适用于所有的Linux发行版。 查看文件大小 du -h --max-depth=2 | sort -n df -lh df -hl 查看磁盘剩余空间 df -h 查看每个根路径的分区大小 du -sh [目录名] 返回该目录的大小 du -sm [文件夹] 返回该文件夹总M数 du -h [目录名] 查看指定文件夹下的所有文件大小（包含子文件夹） [Linux 查看磁盘空间](https://www.runoob.com/w3cnote/linux-view-disk-space.html) 传输文件 单个文件：scp xxx.jar 59.78.194.17:/home 文件夹 ：scp -r xxx/ 59.78.194.17:/home CentOS 7 开放防火墙端口命令 (base) [root@localhost ~]# firewall-cmd --zone=public --add-port=80/tcp --permanent success (base) [root@localhost ~]# firewall-cmd --reload success https://blog.csdn.net/achang21/article/details/52538049 查看指定 PID 的进程详情 ll /proc/PID 改变.sh 文件为可执行 chmod +x XXX.sh Error 处理 /bin/bash^M: 坏的解释器: 没有该文件或目录 sed -i 's/\\r$//' xxx.sh 这个文件在 Windows 下编辑过，在 Windows 下每一行结尾是\\n\\r，而 Linux 下则是\\n 该命令会把 xxx.sh 中的行尾的\\r 替换为空白 删除目录下文件大小为 0KB 的文件 find . -name \"*\" -type f -size 0c | xargs -n 1 rm -f ssh ssh-keygen ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.xx.xx cd ~/.ssh vim authorized_keys ssh root@192.168.xx.xx https://blog.csdn.net/jeikerxiao/article/details/84105529?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase 若是 ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.xx.xx 时出现报错： /usr/bin/ssh-copy-id: ERROR: @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ERROR: @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ ERROR: @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ERROR: IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! ERROR: Someone could be eavesdropping on you right now (man-in-the-middle attack)! ERROR: It is also possible that a host key has just been changed. ERROR: The fingerprint for the ECDSA key sent by the remote host is ERROR: SHA256:IttA7rpqS9QiVTNnEwNrlT9j5aXD2GpM/qytuaTlKyE. ERROR: Please contact your system administrator. ERROR: Add correct host key in /c/Users/iHao/.ssh/known_hosts to get rid of this message. ERROR: Offending ECDSA key in /c/Users/iHao/.ssh/known_hosts:11 ERROR: ECDSA host key for 42.192.123.45 has changed and you have requested strict checking. ERROR: Host key verification failed. 原因是之前已经配置过，但是失效了，这个时候重新配置的话需要先把 ~/.ssh/known_hosts 里对应的数据删除掉。 挂在硬盘 fdisk -l Disk /dev/sda: 512.1 GB, 512110190592 bytes, 1000215216 sectors ... Disk /dev/sdb: 1000.2 GB, 1000204886016 bytes, 1953525168 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disk label type: dos Disk identifier: 0x72a91a19 Device Boot Start End Blocks Id System /dev/sdb1 2048 1953525167 976761560 83 Linux mount /dev/sdb1 /data # 要挂载到的位置 "},"403/数据结构.html":{"url":"403/数据结构.html","title":"数据结构","keywords":"","body":""},"403/算法模板.html":{"url":"403/算法模板.html","title":"算法模板","keywords":"","body":"算法模板 单调队列 https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/dan-tiao-dui-lie class MonotonicQueue { private: deque data; public: void push(int n) { while (!data.empty() && data.back() maxSlidingWindow(vector& nums, int k) { MonotonicQueue window; vector res; for (int i = 0; i 单调栈 https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/dan-tiao-zhan ''' 给一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。 解释：第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。 ''' vector nextGreaterElement(vector& nums) { vector ans(nums.size()); // 存放答案的数组 stack s; for (int i = nums.size() - 1; i >= 0; i--) { // 倒着往栈里放 while (!s.empty() && s.top() 滑动窗口 /* 滑动窗口算法框架 */ void slidingWindow(string s, string t) { unordered_map need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; while (right "},"技能树/阅读笔记.html":{"url":"技能树/阅读笔记.html","title":"阅读笔记","keywords":"","body":"读书笔记 Java 8 SDK https://docs.oracle.com/javase/8/docs/api/ 《On Java 8》中文版 事实上的《Java 编程思想》第5版 https://lingcoder.gitee.io/onjava8/#/ 接口 每个对象仅能接受特定的请求。我们向对象发出的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类型”与“接口”的对应关系是面向对象程序设计的基础。 一个接口表示：所有实现了该接口的类看起来都像这样。因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需知道这些。所以，接口被用来建立类之间的协议。 基本类型默认值 如果类的成员变量（字段）是基本类型，那么在类初始化时，这些类型将会被赋予一个初始值。但是这种默认值的赋予并不适用于局部变量 —— 那些不属于类的字段的变量。 下划线 Java 7 中有一个深思熟虑的补充：我们可以在数字字面量中包含下划线 _，以使结果更清晰。这对于大数值的分组特别有用。代码示例 // operators/Underscores.java public class Underscores { public static void main(String[] args) { double d = 341_435_936.445_667; System.out.println(d); int bin = 0b0010_1111_1010_1111_1010_1111_1010_1111; System.out.println(Integer.toBinaryString(bin)); System.out.printf(\"%x%n\", bin); // [1] long hex = 0x7f_e9_b7_aa; System.out.printf(\"%x%n\", hex); } } // 输出： 3.41435936445667E8 101111101011111010111110101111 2fafafaf 7fe9b7aa 标签跳转 简单的一个 continue 会退回最内层循环的开头（顶部），并继续执行。 带有标签的 continue 会到达标签的位置，并重新进入紧接在那个标签后面的循环。 break 会中断当前循环，并移离当前标签的末尾。 带标签的 break 会中断当前循环，并移离由那个标签指示的循环的末尾。 在 Java 里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中 break 或 continue。 this关键字 this 关键字在向其他方法传递当前对象时很有用。 初始化的顺序 类中定义的对象全都会在调用构造器或其他方法之前得到初始化 "},"技能树/git.html":{"url":"技能树/git.html","title":"Git","keywords":"","body":"Git git 无法添加文件夹下的文件 无论使用啥命令，都无法将文件夹下的某些文件添加进 Git 进行版本控制原来是子文件夹下面含有 .git 文件夹，因此导致该子文件夹无法被 Git 跟踪，可以通过以下方法解决： git rm --cached folder git add folder 其中 folder 为子文件夹。 新仓库 简易的命令行入门教程: Git 全局设置: git config --global user.name \"lab1008\" git config --global user.email \"lab1008@163.com\" 创建 git 仓库: mkdir lab_1008 cd lab_1008 git init touch README.md git add README.md git commit -m \"first commit\" git remote add origin git@gitee.com:lab_1008/lab_1008.git git push -u origin master 已有仓库? cd existing_git_repo git remote add origin git@gitee.com:lab_1008/lab_1008.git git push -u origin master git 撤销commit 撤回最近一次的commit(撤销commit，不撤销git add) git reset --soft HEAD~1 撤回最近一次的commit(撤销commit，撤销git add) git reset --mixed HEAD~1 撤回最近一次的commit(撤销commit，撤销git add,还原改动的代码) git reset --hard HEAD~1 git 删除 # use --cached to keep the file $ git rm --cached xxx.pdf # -f to force removal $ git rm -f xxx.pdf "},"技能树/踩坑.html":{"url":"技能树/踩坑.html","title":"踩坑","keywords":"","body":"踩过的坑 Java java.lang.IllegalStateException;java.lang.NoClassDefFoundError java.lang.IllegalStateException: Failed to load ApplicationContext at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:124) at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:83) at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:189) at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:131) Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'messageSource' defined in file [D:\\Users\\billy.hu\\Documents\\VIP\\vdmp\\admin\\admin-webapp\\out\\production\\resources\\conf\\applicationContext.xml]: BeanPostProcessor before instantiation of bean failed; nested exception is java.lang.NoClassDefFoundError: Lcom/vip/imp/dmp/base/service/OperaterHistoryService; at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:477) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry. "},"技能树/Docker.html":{"url":"技能树/Docker.html","title":"Docker","keywords":"","body":"Docker 安装 https://docs.docker.com/get-docker/ 镜像加速器 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json 一些命令 启动服务sudo systemctl start docker 创建容器sudo docker run --runtime=nvidia -p 5592:5592 -p 5593:5593 -p 8899:8888 -p 8022:22 --name=\"hzh_tf\" -v ~/workspace/hzh/remote_workspace:/workspace/hzh/remote_workspace -it tensorflow/tensorflow:1.14.0-gpu-py3 /bin/bash 启动容器sudo docker start hzh_tf 进入容器sudo docker attach hzh_tf docker exec -it mysql /bin/bash 退出不关闭容器Ctrl + P + Q 重启ssh服务service ssh restart 远程登陆ssh root@59.78.194.131 -p 8022 / 1234 重启应用docker restart redis 常用容器 docker里启动mysql sudo docker run -p 3306:3306 --name mysql -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/ mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 Docker安装Mysql5.7 docker redis docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf TensorFlow1.12容器 docker run --runtime=nvidia -it --rm tensorflow/tensorflow:1.12.0-gpu-py3 sudo docker run --runtime=nvidia -p 5592:5592 -p 5593:5593 -p 8899:8888 -p 8022:22 --name=\"hzh_tf\" -v ~/workspace/hzh/remote_workspace:/workspace/hzh/remote_workspace -it tensorflow/tensorflow:1.14.0-gpu-py3 /bin/bash 搭建tf环境 相关参考 PyCharm+Docker：打造最舒适的深度学习炼丹炉 Docker 退出容器但不关闭当前容器 查看tensorflow是否支持GPU，以及测试程序 注意点 PyCharm+Docker：打造最舒适的深度学习炼丹炉中提到的配置ssh，可能还是有问题，需要vim进入到/etc/ssh/sshd_config将PermitRootLogin yes的注释去掉，才可以远程ssh登陆上去。 用lsb_release -a查看可以知道其实该容器本质是个Ubuntu18.04 "},"技能树/工具.html":{"url":"技能树/工具.html","title":"工具","keywords":"","body":" 工具使用 Vagrant 虚拟机 vagrant init centos/7 vagrant up 启动 vagrant ssh 登陆 Frp https://blog.csdn.net/u013144287/article/details/78589643 Gitbook Gitbook是使用NPM来进行安装的，可以在命令行中输入下面的命令进行安装： $ npm install gitbook -g 让gitbook支持命令行： $ npm install -g gitbook-cli 检验是否安装成功: $ gitbook -V 1.5.0 初始化一本书 $ gitbook init 安装插件 插件配置在book.json中 $ gitbook install 开启服务 $ gitbook serve Hexo 常用命令 简写指令 hexo n \"我的第一篇文章\" 等价于 hexo new \"我的第一篇文章\" 还等价于 hexo new post \"我的第一篇文章\" hexo p 等价于 hexo publish hexo g 等价于 hexo generate hexo s 等价于 hexo server hexo d 等价于 hexo deploy hexo deploy -g 等价于 hexo deploy --generate hexo generate -d 等价于 hexo generate --deploy 指令说明 hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。 hexo server -s #以静态模式启动 hexo server -p 5000 #更改访问端口 (默认端口为 4000，'ctrl + c'关闭 server) hexo server -i IP 地址 #自定义 IP hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的 public 文件夹 hexo g #生成静态网页 (执行 $ hexo g 后会在站点根目录下生成 public 文件夹, hexo 会将\"/blog/source/\" 下面的.md 后缀的文件编译为.html 后缀的文件,存放在\"/blog/public/ \" 路径下) hexo d #将本地数据部署到远端服务器(如 github) hexo init 文件夹名称 #初始化 XX 文件夹名称 npm update hexo -g#升级 npm install hexo -g#安装 node-v #查看 node.js 版本号 npm -v #查看 npm 版本号 git --version #查看 git 版本号 hexo -v #查看 hexo 版本号 Vscode iHao@DESKTOP-1JEODUI MINGW64 /d/Users/iHao/Documents/Code/book (master) $ ll bash: ll: command not found 配置文件中加： \"terminal.integrated.shellArgs.windows\": [ \"-i\", \"-l\" ] 可以用 ll 等命令 VsCode 中用 Latex https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshophttps://zhuanlan.zhihu.com/p/38178015 setting.json { // LaTeX \"latex-workshop.latex.autoBuild.run\": \"never\", \"latex-workshop.message.error.show\": false, \"latex-workshop.message.warning.show\": false, \"latex-workshop.latex.tools\": [ { // 编译工具和命令 \"name\": \"xelatex\", \"command\": \"xelatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"-pdf\", \"%DOCFILE%\" ] }, { \"name\": \"pdflatex\", \"command\": \"pdflatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOCFILE%\" ] }, { \"name\": \"bibtex\", \"command\": \"bibtex\", \"args\": [\"%DOCFILE%\"] } ], \"latex-workshop.latex.recipes\": [ { \"name\": \"xelatex\", \"tools\": [\"xelatex\"] }, { \"name\": \"pdflatex\", \"tools\": [\"pdflatex\"] }, { \"name\": \"xe->bib->xe->xe\", \"tools\": [\"xelatex\", \"bibtex\", \"xelatex\", \"xelatex\"] }, { \"name\": \"pdf->bib->pdf->pdf\", \"tools\": [\"pdflatex\", \"bibtex\", \"pdflatex\", \"pdflatex\"] } ], \"latex-workshop.view.pdf.viewer\": \"external\", \"latex-workshop.view.pdf.external.viewer.command\": \"\\\"C:/Program Files/SumatraPDF/SumatraPDF.exe\\\"\", \"latex-workshop.view.pdf.external.viewer.args\": [ \"-forward-search\", \"%TEX%\", \"%LINE%\", \"-reuse-instance\", \"-inverse-search\", \"\\\"C:/Program Files/Microsoft VS Code/Code.exe\\\" \\\"C:/Program Files/Microsoft VS Code/resources/app/out/cli.js\\\" -gr \\\"%f\\\":\\\"%l\\\"\", \"%PDF%\" ], \"latex-workshop.view.pdf.external.synctex.command\": \"C:/Program Files/SumatraPDF/SumatraPDF.exe\", \"latex-workshop.view.pdf.external.synctex.args\": [ \"-forward-search\", \"%TEX%\", \"%LINE%\", \"-reuse-instance\", \"-inverse-search\", \"\\\"C:/Program Files/Microsoft VS Code/Code.exe\\\" \\\"C:/Program Files/Microsoft VS Code/resources/app/out/cli.js\\\" -gr \\\"%f\\\":\\\"%l\\\"\", \"%PDF%\" ] } keybindings.json // Empty [ { \"key\": \"alt+s\", \"command\": \"latex-workshop.synctex\", \"when\": \"editorTextFocus && !isMac\" }, { \"key\": \"alt+b\", \"command\": \"latex-workshop.build\", \"when\": \"editorTextFocus && !isMac\" }, { \"key\": \"alt+t\", \"command\": \"latex-workshop.kill\", \"when\": \"editorTextFocus && !isMac\" }, { \"key\": \"alt+e\", \"command\": \"latex-workshop.recipes\" } ] "},"技能树/kafka.html":{"url":"技能树/kafka.html","title":"Kafka","keywords":"","body":"Kafka 概念 Kafka作为一个集群，运行在一台或者多台服务器上. Kafka 通过 topic 对存储的流数据进行分类。 Topic 就是数据主题，是数据记录发布的地方,可以用来区分业务系统。Kafka中的Topics总是多订阅者模式，一个topic可以拥有一个或者多个消费者来订阅它的数据。 对于每一个topic， Kafka集群都会维持一个分区日志 消费者组中的消费者实例个数不能超过分区的数量 每条记录中包含一个key，一个value和一个timestamp（时间戳）。 kafka终端命令 启动zk： bin/zookeeper-server-start.sh config/zookeeper.properties 启动kafka服务：bin/kafka-server-start.sh config/server.properties kafka生产者：bin/kafka-console-producer.sh --broker-list localhost:9092 --topic topic kafka消费者：bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic topic --from-beginning "},"Java/基础.html":{"url":"Java/基础.html","title":"基础","keywords":"","body":""},"Java/SpringBoot+Vue开发实战笔记/chapter01.html":{"url":"Java/SpringBoot+Vue开发实战笔记/chapter01.html","title":"Chapter01","keywords":"","body":"第一章 Spring Boot 入门 创建父子项目的SpringBoot项目 创建父项目 不选依赖创建空项目，完成后将以下红框中删掉，因为之后还创建子项目，父项目里不直接写代码。 设置Maven依赖 如是第一次创建，会Maven会去下载很多依赖，所以需要等待一段时间。这里Maven默认使用了国外的源，国内的话可以手动设置阿里源。 若原本不存在setting.xml，则创建一个，然后填入以下内容： alimaven aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ central 创建子项目 配置父项目 4.0.0 pom org.springframework.boot spring-boot-starter-parent 2.4.0 top.huzhenhao springboot 0.0.1-SNAPSHOT springbootlearning Demo project for Spring Boot 1.8 chapter01 org.springframework.boot spring-boot-starter org.springframework.boot spring-boot-starter-test test org.springframework.boot spring-boot-maven-plugin top.huzhenhao chapter01 0.0.1-SNAPSHOT 配置好后点击 Load Maven Changes。 配置子项目 4.0.0 chapter01 0.0.1-SNAPSHOT chapter01 Demo project for Spring Boot top.huzhenhao springboot 0.0.1-SNAPSHOT org.springframework.boot spring-boot-starter-web 启动测试 添加测试接口 @RestController public class Hello { @GetMapping(\"/hello\") public String hello(){ return \"Hello SpringBoot\"; } } 点击运行即可 访问 ： http://localhost:8080/hello ，若显示 \"Hello SpringBoot\" 即成功。 若需要继续创建其他子项目，按上面步骤创建即可，注意需要在父项目 pom 中配置一下子模块。 "},"Java/SpringBoot+Vue开发实战笔记/chapter02.html":{"url":"Java/SpringBoot+Vue开发实战笔记/chapter02.html","title":"Chapter02","keywords":"","body":"第二章 Spring Boot 基础配置 Tomcat配置 server.port=8081 server.error.path=/error server.servlet.session.timeout=30m server.servlet.context-path=/chapter02 server.tomcat.uri-encoding=utf-8 server.tomcat.threads.max=500 #server.tomcat.basedir= Tomcat 运行日志和临时文件目录，不配置则使用默认 HTTPS 配置 java 提供的 keytool 工具生成数字证书 keytool -genkey -alias tomcathttps -keyalg RSA -keysize 2048 -keystore hzh.p12 -validity 365 配置文件中添加 server.ssl.key-store=hzh.p12 server.ssl.key-alias=tomcathttps server.ssl.key-store-password=123456 # 命令中输入的密码 package top.huzhenhao.chapter02.config; import org.apache.catalina.Context; import org.apache.catalina.connector.Connector; import org.apache.tomcat.util.descriptor.web.SecurityCollection; import org.apache.tomcat.util.descriptor.web.SecurityConstraint; import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class TomcatConfig { //将http重定向至https @Bean public TomcatServletWebServerFactory tomcatServletWebServerFactory() { TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory() { @Override protected void postProcessContext(Context context) { //SecurityConstraint必须存在，可以通过其为不同的URL设置不同的重定向策略。 SecurityConstraint securityConstraint = new SecurityConstraint(); securityConstraint.setUserConstraint(\"CONFIDENTIAL\"); SecurityCollection collection = new SecurityCollection(); collection.addPattern(\"/*\"); securityConstraint.addCollection(collection); context.addConstraint(securityConstraint); } }; factory.addAdditionalTomcatConnectors(createHttpConnector()); return factory; } private Connector createHttpConnector() { Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\"); connector.setScheme(\"http\"); connector.setSecure(false); connector.setPort(8080); connector.setRedirectPort(8081); return connector; } } 访问： https://localhost:8081/chapter02/hello http://localhost:8080/chapter02/hello "},"Java/SpringBoot+Vue开发实战笔记/chapter03.html":{"url":"Java/SpringBoot+Vue开发实战笔记/chapter03.html","title":"Chapter03","keywords":"","body":"第三章 Spring Boot 整合视图层技术 整合Thymeleaf 添加依赖 org.springframework.boot spring-boot-starter-thymeleaf 配置Thymeleaf #thymelea模板配置 spring.thymeleaf.cache=true spring.thymeleaf.check-template=true spring.thymeleaf.check-template-location=true spring.thymeleaf.encoding=UTF-8 spring.thymeleaf.prefix=classpath:/templates/ # 模板文件位置 spring.thymeleaf.servlet.content-type=text/html spring.thymeleaf.suffix=.html 控制器代码 // Book.java @Component public class Book { private String name; private String author; private Float price; // ... ... } // BookController.java import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.servlet.ModelAndView; import top.huzhenhao.chapter03.pojo.Book; import java.util.ArrayList; @RestController public class BookController { @GetMapping(\"/books\") public ModelAndView books(){ ArrayList books = new ArrayList<>(); Book book1 = new Book(); book1.setName(\"三国演义\"); book1.setAuthor(\"罗贯中\"); book1.setPrice(30f); Book book2 = new Book(); book2.setName(\"红楼梦\"); book2.setAuthor(\"曹雪芹\"); book2.setPrice(35f); books.add(book1); books.add(book2); ModelAndView mv = new ModelAndView(); mv.addObject(\"books\", books); mv.setViewName(\"books\"); return mv; } } 创建视图 resources/templates/books.html 图书列表 书名 作者 价格 运行 http://localhost:8080/books "},"Java/SpringBoot+Vue开发实战笔记/chapter04.html":{"url":"Java/SpringBoot+Vue开发实战笔记/chapter04.html","title":"Chapter04","keywords":"","body":"第四章 Spring Boot 整合 Web 开发 4.1 返回 JSON 数据 @Component public class Book { private String name; private String author; @JsonIgnore private Float price; @JsonFormat(pattern = \"yyyy-MM-dd\") private Date publishDate; } 4.2 静态资源访问 由于我使用了父子工程的方式，一开始按书本教程操作并不能访问到图片。 后来了解到 classpath 是和 xxx.iml 文件有关系的，因为我之前建父项目时没有把父项目的 iml 文件删除，所以怀疑时父项目的 iml 文件优先级更高使得访问失败，尝试把父项目的 iml 文件删除后再访问，可以得到静态资源。 4.3 文件上传 html文件 上传文件 --> application.properties # 配置文件传输 spring.servlet.multipart.enabled =true # 文件写入磁盘的阈值 spring.servlet.multipart.file-size-threshold =0 # 文件保存的位置（不设置的话在tomcat下） spring.servlet.multipart.location=E:\\\\tomcat-temp\\\\ # 单个数据的大小 spring.servlet.multipart.max-file-size=1MB # 总数据的大小 spring.servlet.multipart.max-request-size=10MB # 是否延迟解析 spring.servlet.multipart.resolve-lazily=false java @RestController @PropertySource(value = {\"classpath:application.properties\"}) public class FileUploadController { // String realPath = req.getSession().getServletContext().getRealPath(\"/uploadFile/\"); @Value(\"${spring.servlet.multipart.location}\") String realPath; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd/\"); @PostMapping(\"/upload\") public String upload(MultipartFile uploadFile, HttpServletRequest req) { String format = sdf.format(new Date()); File folder = new File(realPath + format); if (!folder.isDirectory()) { folder.mkdirs(); } // 重命名 String oldName = uploadFile.getOriginalFilename(); String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(\".\"), oldName.length()); try{ // 保存文件 uploadFile.transferTo(new File(folder, newName)); // 生成访问路径 return req.getScheme() + \"://\" + req.getServerName() + \":\" + req.getServerPort() + \"/uploadFile/\" + format + newName; } catch (IOException e) { e.printStackTrace(); } return \"上传失败！\"; } @PostMapping(\"/uploads\") public String uploads(MultipartFile[] uploadFiles, HttpServletRequest req) { String format = sdf.format(new Date()); File folder = new File(realPath + format); if (!folder.isDirectory()) { folder.mkdirs(); } // 循环依次保存 for (MultipartFile uploadFile : uploadFiles) { String oldName = uploadFile.getOriginalFilename(); String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(\".\"), oldName.length()); try{ uploadFile.transferTo(new File(folder, newName)); } catch (IOException e) { e.printStackTrace(); return \"上传失败！\"; } } return \"上传成功！\"; } } 4.4 ControllerAdvice 全局异常处理 @ControllerAdvice public class CustomExceptionHandler { @ExceptionHandler(MaxUploadSizeExceededException.class) public void uploadException(MaxUploadSizeExceededException e, HttpServletResponse resp) throws IOException { resp.setContentType(\"text/html;charset=utf-8\"); PrintWriter out = resp.getWriter(); out.write(\"超出文件大小限制\"); out.flush(); out.close(); } } 全局参数 @ControllerAdvice public class GlobalConfig { @ModelAttribute(value = \"info1\") public Map userInfo1(){ HashMap map = new HashMap<>(); map.put(\"username\", \"张三\"); map.put(\"gender\", \"男\"); return map; } @ModelAttribute(value = \"info2\") public String userInfo2(){ return \"张三\"; } } @Controller public class HelloController { @GetMapping(\"/hello\") @ResponseBody public void hello(Model model) { Map map = model.asMap(); Set keySet = map.keySet(); for (String key : keySet) { Object value = map.get(key); System.out.println(key + \">>>>>>>\" + value); } } } // 输出： info1>>>>>>>{gender=男, username=张三} info2>>>>>>>张三 4.5 配置错误页 Title 时间 status error message path 4.6 跨域 注解方式 @PostMapping(\"/addbook\") @CrossOrigin(value = \"http://localhost:8080\", maxAge = 1800, allowedHeaders = \"*\") public String addBook(String name){ return \"receive:\" + name; } @GetMapping(\"/getbook\") @CrossOrigin(value = \"http://localhost:8080\", maxAge = 1800, allowedHeaders = \"*\") public String getBook(){ return \"receive: GET\"; } @DeleteMapping(\"/book/{id}\") @CrossOrigin(value = \"http://localhost:8080\", maxAge = 1800, allowedHeaders = \"*\") public String deleteBookById(@PathVariable Long id){ return String.valueOf(id); } 全局配置 @Configuration public class MyWebMvcConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"/**\") .allowedHeaders(\"*\") .allowedMethods(\"*\") .maxAge(1800) .allowedOrigins(\"http://localhost:8080\"); } } 4.8 注册拦截器 实现HandlerInterceptor接口 public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"MyInterceptor>>>preHandle\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"MyInterceptor>>>postHandle\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"MyInterceptor>>>afterCompletion\"); } } 配置拦截器 @Configuration public class MyWebMvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()) .addPathPatterns(\"/**\") // 拦截路径 .excludePathPatterns(\"/hello\"); // 排除的路径 } } 4.9 启动系统任务 CommandLineRunner @Component @Order(1) // 数字越小越优先 public class MyCommandLineRunner1 implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(\"MyCommandLineRunner1>>>\" + Arrays.toString(args)); } } @Component @Order(2) // 数字越小越优先 public class MyCommandLineRunner2 implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(\"MyCommandLineRunner2>>>\" + Arrays.toString(args)); } } 启动时输出： 2020-11-29 10:26:09.263 INFO 16120 --- [ main] t.h.chapter04.Chapter04Application : Started Chapter04Application in 1.327 seconds (JVM running for 2.041) MyCommandLineRunner1>>>[三国演义, 罗贯中] MyCommandLineRunner2>>>[三国演义, 罗贯中] ApplicationRunner @Component @Order(1) // 数字越小越优先 public class MyApplicationRunner implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { // 与 CommandLineRunner 区别在于run方法的参数上 List nonOptionArgs = args.getNonOptionArgs(); System.out.println(\"nonOptionArgs>>>\"+nonOptionArgs); Set optionNames = args.getOptionNames(); for (String optionName : optionNames) { System.out.println(\"Key:\" + optionName + \";value:\" + args.getOptionValues(optionName)); } } } 4.12 AOP 依赖 org.springframework.boot spring-boot-starter-aop 服务 @Service public class UserService { public String getUserById(Integer id) { System.out.println(\"get...\"); return \"user\"; } } 切面 @Component @Aspect public class LogAspect { @Pointcut(\"execution(* top.huzhenhao.chapter04.service.*.*(..))\") public void pc1(){} @Before(value = \"pc1()\") public void before(JoinPoint jp) { String name = jp.getSignature().getName(); System.out.println(name + \"方法开始执行...\"); } @After(value = \"pc1()\") public void after(JoinPoint jp) { String name = jp.getSignature().getName(); System.out.println(name + \"方法执行结束...\"); } @AfterReturning(value = \"pc1()\", returning = \"result\") public void afterReturning(JoinPoint jp, Object result) { String name = jp.getSignature().getName(); System.out.println(name + \"方法返回值为：\" + result); } @AfterThrowing(value = \"pc1()\", throwing = \"e\") public void afterThrowing(JoinPoint jp, Exception e) { String name = jp.getSignature().getName(); System.out.println(name + \"方法抛出异常为：\" + e); } @Around(\"pc1()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { return pjp.proceed(); } } 测试 @RestController public class UserController { @Autowired UserService userService; @GetMapping(\"/getUser\") public String getUserById(Integer id) { System.out.println(\"UserController>>>getUserById\"); return userService.getUserById(id); } } // 访问 http://localhost:8082/getUser 输出： MyInterceptor>>>preHandle UserController>>>getUserById getUserById方法开始执行... get... getUserById方法返回值为：user getUserById方法执行结束... MyInterceptor>>>postHandle MyInterceptor>>>afterCompletion "},"Java/SpringBoot+Vue开发实战笔记/chapter05.html":{"url":"Java/SpringBoot+Vue开发实战笔记/chapter05.html","title":"Chapter05","keywords":"","body":"第五章 Spring Boot 整合持久层技术 5.1 整合 JdbcTemplate 创建数据 USE `study`; CREATE TABLE `book` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(128) NOT NULL DEFAULT '' COMMENT '书名', `author` VARCHAR(64) NOT NULL DEFAULT '' COMMENT '作者', PRIMARY KEY (`id`) USING BTREE ) COMMENT='书表' ENGINE=InnoDB AUTO_INCREMENT=1; INSERT INTO book (id,name,author) VALUES (1, '三国演义', '罗贯中'), (2, '水浒传', '施耐庵'); 连接测试，Idea默认配置连接MySQL时出错，改为以下版本可 新建项目，添加依赖 org.springframework.boot spring-boot-starter-jdbc mysql mysql-connector-java com.alibaba druid 1.1.10 数据库配置 spring.datasource.type=com.alibaba.druid.pool.DruidDataSource # spring.datasource.url=jdbc:mysql://59.78.194.153:3306/study spring.datasource.url=jdbc:mysql://59.78.194.153:3306/study?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Hongkong spring.datasource.username=root spring.datasource.password=123456 创建实体类 public class Book { private Integer id; private String name; private String author; } 数据访问层 @Repository public class BookDao { @Autowired JdbcTemplate jdbcTemplate; public int addBook(Book book){ return jdbcTemplate.update(\"INSERT INTO book(name, author) VALUES (?,?)\", book.getName(), book.getAuthor()); } public int updateBook(Book book){ return jdbcTemplate.update(\"UPDATE book SET name=?, author=? WHERE id=?\", book.getName(), book.getAuthor(), book.getId()); } public int deleteBook(Integer id){ return jdbcTemplate.update(\"DELETE FROM book WHERE id=?\", id); } public Book getBookById(Integer id){ return jdbcTemplate.queryForObject(\"SELECT * FROM book WHERE id=?\", new BeanPropertyRowMapper<>(Book.class), id); } public List getAllBooks(){ return jdbcTemplate.query(\"SELECT * FROM book\", new BeanPropertyRowMapper<>(Book.class)); } } 服务层 @Service public class BookService { @Autowired BookDao bookDao; public int addBook(Book book) { return bookDao.addBook(book); } public int updateBook(Book book) { return bookDao.updateBook(book); } public int deleteBook(Integer id) { return bookDao.deleteBook(id); } public Book getBookById(Integer id) { return bookDao.getBookById(id); } public List getAllBooks(){ return bookDao.getAllBooks(); } } 控制层 @RestController public class BookController { @Autowired BookService bookService; @GetMapping(\"/{id}\") public void getBook(@PathVariable Integer id){ Book book = bookService.getBookById(id); System.out.println(\"getBookById>>>\" + book.toString()); } @GetMapping(\"/bookOps\") public void bookOps(){ Book book1 = new Book(); book1.setName(\"西厢记\"); book1.setAuthor(\"王实甫\"); int i = bookService.addBook(book1); // 其他接口省略没测 System.out.println(\"addBook>>>\" + i); List allBooks = bookService.getAllBooks(); for (Book book : allBooks) { System.out.println(\"getAllBooks>>>\" + book.toString()); } } } 测试 访问 http://localhost:8080/bookOps 报错： 2020-11-29 21:58:46.499 ERROR 20612 --- [eate-1152340022] com.alibaba.druid.pool.DruidDataSource : create connection SQLException, url: jdbc:mysql://59.78.194.153:3306, errorCode 0, state 08S01 com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. at com.mysql.cj.jdbc.exceptions.SQLError.createCommunicationsException(SQLError.java:174) ~[mysql-connector-java-8.0.22.jar:8.0.22] at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:64) ~[mysql-connector-java-8.0.22.jar:8.0.22] at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:836) ~[mysql-connector-java-8.0.22.jar:8.0.22] at com.mysql.cj.jdbc.ConnectionImpl.(ConnectionImpl.java:456) ~[mysql-connector-java-8.0.22.jar:8.0.22] at com.mysql.cj.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:246) ~[mysql-connector-java-8.0.22.jar:8.0.22] at com.mysql.cj.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:198) ~[mysql-connector-java-8.0.22.jar:8.0.22] at com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1558) ~[druid-1.1.10.jar:1.1.10] at com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1623) ~[druid-1.1.10.jar:1.1.10] at com.alibaba.druid.pool.DruidDataSource$CreateConnectionThread.run(DruidDataSource.java:2468) ~[druid-1.1.10.jar:1.1.10] Caused by: com.mysql.cj.exceptions.CJCommunicationsException: Communications link failure 解决方法: 配置文件数据库连接URL添加后缀 spring.datasource.url=jdbc:mysql://59.78.194.153:3306/study?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Hongkong 访问成功 addBook>>>1 getAllBooks>>>Book{id=1, name='三国演义', author='罗贯中'} getAllBooks>>>Book{id=2, name='水浒传', author='施耐庵'} getAllBooks>>>Book{id=3, name='西厢记', author='王实甫'} # 代码新插入的数据 5.2 整合MyBatis 依赖 org.mybatis.spring.boot mybatis-spring-boot-starter 2.1.3 数据访问层 使用了MybatisPlus插件生成 @Mapper public interface BookMapper { int deleteByPrimaryKey(Integer id); int insert(Book record); int insertSelective(Book record); Book selectByPrimaryKey(Integer id); List getAllBooks(); // 手动新增方法 int updateByPrimaryKeySelective(Book record); int updateByPrimaryKey(Book record); } id, `name`, author select from book where id = #{id,jdbcType=INTEGER} select * from book delete from book where id = #{id,jdbcType=INTEGER} insert into book (`name`, author) values (#{name,jdbcType=VARCHAR}, #{author,jdbcType=VARCHAR}) insert into book `name`, author, #{name,jdbcType=VARCHAR}, #{author,jdbcType=VARCHAR}, update book `name` = #{name,jdbcType=VARCHAR}, author = #{author,jdbcType=VARCHAR}, where id = #{id,jdbcType=INTEGER} update book set `name` = #{name,jdbcType=VARCHAR}, author = #{author,jdbcType=VARCHAR} where id = #{id,jdbcType=INTEGER} 服务层 @Service public class BookMapperService { @Autowired BookMapper bookMapper; public int addBook(Book book) { return bookMapper.insert(book); } public int updateBook(Book book) { return bookMapper.updateByPrimaryKey(book); } public int deleteBook(Integer id) { return bookMapper.deleteByPrimaryKey(id); } public Book getBookById(Integer id) { return bookMapper.selectByPrimaryKey(id); } public List getAllBooks(){ return bookMapper.getAllBooks(); } } 控制层 代码与之前一样，使用的Service换成BookMapperService *配置Pom 父项目或子项目的pom.xml 中添加都可以；关键步骤，不配置的话无法访问到BookMapper.xml，以至无法调用数据层 src/main/java **/*.properties **/*.xml false src/main/resources **/*.properties **/*.xml false "},"Java/SpringBoot+Vue开发实战笔记/chapter06.html":{"url":"Java/SpringBoot+Vue开发实战笔记/chapter06.html","title":"Chapter06","keywords":"","body":"第六章 Spring Boot 整合NoSQL 6.1.1 整合Redis 安装Redis 参考： https://huzhenhao.top/2020/11/30/Docker%E9%87%8C%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8Redis/ 创建项目添加依赖 org.springframework.boot spring-boot-starter-data-redis 配置 # REDIS (RedisProperties) # Redis数据库索引（默认为0） spring.redis.database=0 # Redis服务器地址 spring.redis.host=59.xx # Redis服务器连接端口 spring.redis.port=6378 # Redis服务器连接密码（默认为空） spring.redis.password=1xx # 连接池最大连接数（使用负值表示没有限制） spring.redis.pool.max-active=8 # 连接池最大阻塞等待时间（使用负值表示没有限制） spring.redis.pool.max-wait=-1 # 连接池中的最大空闲连接 spring.redis.pool.max-idle=8 # 连接池中的最小空闲连接 spring.redis.pool.min-idle=0 # 连接超时时间（毫秒） spring.redis.timeout=0 实体类 public class Book implements Serializable { private Integer id; private String name; private String author; } 控制层 @RestController public class BookController { @Autowired RedisTemplate redisTemplate; @Autowired StringRedisTemplate stringRedisTemplate; @GetMapping(\"/t1\") public void getBook(){ ValueOperations ops1 = stringRedisTemplate.opsForValue(); ops1.set(\"name\", \"三国演义\"); String name = ops1.get(\"name\"); System.out.println(\"name:\" + name); ValueOperations ops2 = redisTemplate.opsForValue(); Book book = new Book(); book.setId(1); book.setName(\"红楼梦\"); book.setAuthor(\"曹雪芹\"); ops2.set(\"book\", book); Book book1 = (Book) ops2.get(\"book\"); System.out.println(\"book1:\" + book1); } } 测试 访问：http://localhost:8080/t1 name:三国演义 book1:Book{id=1, name='红楼梦', author='曹雪芹'} 6.1.2 整合Redis集群 搭建Redis集群 没看参考书上，而是使用了Docker，笔记见此 依赖 org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-data-redis redis.clients jedis org.springframework.data spring-data-redis org.apache.commons commons-pool2 配置文件 使用了application.yml ，不是 .properties spring: redis: cluster: ports: - 7001 - 7002 - 7003 - 7004 - 7005 - 7006 host: 59.78.194.153 poolConfig: max-total: 8 max-idle: 8 max-wait-millis: -1 min-idle: 0 配置Redis RedisConfig.java @Configuration @ConfigurationProperties(\"spring.redis.cluster\") public class RedisConfig { List ports; String host; JedisPoolConfig poolConfig; @Bean RedisClusterConfiguration redisClusterConfiguration(){ RedisClusterConfiguration configuration = new RedisClusterConfiguration(); List nodes = new ArrayList<>(); for (Integer port : ports) { nodes.add(new RedisNode(host, port)); } // configuration.setPassword(RedisPassword.of(“xxx”)); // 没有密码 configuration.setClusterNodes(nodes); return configuration; } @Bean JedisConnectionFactory jedisConnectionFactory(){ JedisConnectionFactory factory = new JedisConnectionFactory(redisClusterConfiguration(), poolConfig); return factory; } @Bean RedisTemplate redisTemplate(){ RedisTemplate redisTemplate = new RedisTemplate(); redisTemplate.setConnectionFactory(jedisConnectionFactory()); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); return redisTemplate; } @Bean StringRedisTemplate stringRedisTemplate(){ StringRedisTemplate stringRedisTemplate = new StringRedisTemplate(jedisConnectionFactory()); stringRedisTemplate.setKeySerializer(new StringRedisSerializer()); stringRedisTemplate.setValueSerializer(new StringRedisSerializer()); return stringRedisTemplate; } // getter() and setter() } 控制层 代码同前 测试 访问 http://localhost:8080/t1 后，看redis数据库情况 6.2 整合MongoDB todo 6.3 Session共享 6.3.1 Session共享配置 依赖 org.springframework.boot spring-boot-starter-data-redis io.lettuce lettuce-core redis.clients jedis org.springframework.session spring-session-data-redis Redis配置 同6.1.1 配置 控制层 @RestController public class HelloController { @Value(\"${server.port}\") // 要在application.propertise中也配一下，不然打包会失败 String port; @GetMapping(\"/save\") // 与书上不同换成GET，方便直接浏览器测试 public String saveName(String name, HttpSession session) { session.setAttribute(\"name\", name); return port; } @GetMapping(\"/get\") public String getName(HttpSession session) { return port + \":\" + session.getAttribute(\"name\").toString(); } } 运行 用maven打包，然后把jar包放在下一步配好 Nginx 的服务器上运行 java -jar chapter06-0.0.1-SNAPSHOT.jar --server.port=8080 java -jar chapter06-0.0.1-SNAPSHOT.jar --server.port=8081 6.3. 2 安装Nginx yum 安装 安装成功，但是上一步测试没有成功，502 网关错误（应该和nginx配置没有关系，错在我最初把服务起在自己的机器上，跨域了可能）；当时不确定是不是nginx安装不对导致，所以后来又换了源码安装尝试。 1. 安装 Nginx yum 安装 nginx 非常简单，就输入一条命令即可。 $ sudo yum -y install nginx # 安装 nginx $ sudo yum remove nginx # 卸载 nginx 使用 yum 进行 Nginx 安装时，Nginx 配置文件在 /etc/nginx 目录下。 2. 配置 Nginx 服务 $ sudo systemctl enable nginx # 设置开机启动 $ sudo service nginx start # 启动 nginx 服务 $ sudo service nginx stop # 停止 nginx 服务 $ sudo service nginx restart # 重启 nginx 服务 $ sudo service nginx reload # 重新加载配置，一般是在修改过 nginx 配置文件时使用。 源码安装 安装 官网地址：http://www.nginx.org # 下载源码 (base) [root@localhost nginx]# wget http://nginx.org/download/nginx-1.19.5.tar.gz # 解压 (base) [root@localhost nginx]# tar -zxvf nginx-1.19.5.tar.gz # 编译安装 (base) [root@localhost nginx]# cd nginx-1.19.5/ (base) [root@localhost nginx-1.19.5]# ./configure (base) [root@localhost nginx-1.19.5]# make (base) [root@localhost nginx-1.19.5]# make install # 启动 (base) [root@localhost nginx-1.19.5]# /usr/local/nginx/sbin/nginx 此时可访问 ip 看 修改配置 (base) [root@localhost nginx-1.19.5]# cd /usr/local/nginx/conf (base) [root@localhost conf]# vim nginx.conf ... upstream hzh { server 59.78.194.153:8080 weight=1; server 59.78.194.153:8081 weight=1; } server { listen 80; server_name localhost; location / { proxy_pass http://hzh; proxy_redirect default; } 重启Nginx (base) [root@localhost conf]# /usr/local/nginx/sbin/nginx -s reload 6.3.3 请求测试 # 访问 http://59.78.194.153/save?name=ihaozz 8081 # 访问 http://59.78.194.153/get 8080:ihaozz 调用 /sava 接口，Nginx转发给 8081 端口的服务器处理，再次调用 /get 接口时，8080 端口服务器返回数据。证明了Session共享的。 "},"Java/SpringBoot+Vue开发实战笔记/chapter07.html":{"url":"Java/SpringBoot+Vue开发实战笔记/chapter07.html","title":"Chapter07","keywords":"","body":"第七章 构建RESTful服务 7.2 JPA实现REST 创建数据库 不用创建表 CREATE DATABASE `jparestful` DEFAULT CHARACTER SET utf8; 依赖 org.springframework.boot spring-boot-starter-data-jpa org.springframework.boot spring-boot-starter-data-rest com.alibaba druid 1.1.10 mysql mysql-connector-java runtime 配置文件 spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.username=root spring.datasource.password=123456 spring.datasource.url=jdbc:mysql://59.78.194.153:3306/jparestful?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Hongkong spring.jpa.hibernate.ddl-auto=update spring.jpa.database=mysql spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL57Dialect spring.jpa.show-sql=true 创建实体类 @Entity(name = \"t_book\") // @Entity 是一个必选的注解，声明这个类对应了一个数据库表。 public class Book { @Id // 注解声明了实体唯一标识对应的属性 @GeneratedValue(strategy = GenerationType.IDENTITY) // 主键自增 private Integer id; private String name; private String author; } 创建BookRepository // 自定义请求路径 @RepositoryRestResource(path = \"bs\", collectionResourceRel = \"bs\", itemResourceRel = \"b\") public interface BookRepository extends JpaRepository { @RestResource(path = \"author\", rel = \"author\") // 自定义查询方法 List findByAuthorContains(@Param(\"author\") String author); @RestResource(path = \"name\", rel = \"name\") // 自定义查询方法 Book findByNameEquals(@Param(\"name\") String name); @Override @RestResource(exported = false) // 隐藏方法 void deleteById(Integer integer); } 测试 ### 添加测试 ### POST http://localhost:8080/books Content-Type: application/json { \"name\": \"三国演义\", \"author\": \"罗贯中\" } ### POST http://localhost:8080/books Content-Type: application/json { \"name\": \"红楼梦\", \"author\": \"曹雪芹\" } ### 查询测试 ### GET http://localhost:8080/books ### 修改测试 ### PUT http://localhost:8080/books/2 Content-Type: application/json { \"name\": \"红楼梦2\", \"author\": \"曹雪芹2\" } ### 删除测试 ### DELETE http://localhost:8080/books/1 7.2 MongoDB实现RESTful todo "},"Java/SpringBoot+Vue开发实战笔记/chapter08.html":{"url":"Java/SpringBoot+Vue开发实战笔记/chapter08.html","title":"Chapter08","keywords":"","body":"第八章 开发者工具与单元测试 8.2 devtools实战 org.springframework.boot spring-boot-devtools true 8.3 单元测试 依赖 junit junit test Service测试 @Service public class HelloService { public String sayHello(String name){ return \"Hello \" + name + \"!\"; } } @SpringBootTest class Chapter08ApplicationTests { @Autowired HelloService helloService; @Test void contextLoads() { String hello = helloService.sayHello(\"iHaozz\"); Assert.assertEquals(hello, \"Hello iHaozz!\"); // import org.junit.Assert; } } Controller测试 @RestController public class HelloController { @GetMapping(\"/hello\") public String hello(String name){ return \"Hello \" + name + \"!\"; } @PostMapping(\"/book\") public String addBook(@RequestBody Book book) { return book.toString(); } } @SpringBootTest class HelloControllerTest { @Autowired HelloService helloService; @Autowired WebApplicationContext wac; MockMvc mockMvc; /** * 在新版本中，spring-boot用的是junit 5.x * 在junit4.x版本之前，生效的是@Before注解 * 然而在junit 5.x中，@Before注解被@BeforeEach所替代 */ @BeforeEach public void before(){ mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); } @Test void hello() throws Exception { MvcResult mvcResult = mockMvc.perform( MockMvcRequestBuilders .get(\"/hello\") .contentType(MediaType.APPLICATION_FORM_URLENCODED) .param(\"name\", \"iHaozz\")) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn(); System.out.println(mvcResult.getResponse().getContentAsString()); } @Test void addBook() throws Exception { ObjectMapper om = new ObjectMapper(); Book book = new Book(); book.setId(1); book.setName(\"三国演义\"); book.setAuthor(\"罗贯中\"); String s = om.writeValueAsString(book); MvcResult mvcResult = mockMvc.perform( MockMvcRequestBuilders .post(\"/book\") .contentType(MediaType.APPLICATION_JSON) .content(s)) .andExpect(MockMvcResultMatchers.status().isOk()) .andReturn(); System.out.println(mvcResult.getResponse().getContentAsString()); } } JSON测试 import org.assertj.core.api.Assertions; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.json.JsonTest; import org.springframework.boot.test.json.JacksonTester; import org.springframework.test.context.junit4.SpringRunner; import top.huzhenhao.chapter08.pojo.Book; import java.io.IOException; @RunWith(SpringRunner.class) @JsonTest public class JSONTest { @Autowired JacksonTester jacksonTester; @Test public void testSerialize() throws IOException { Book book = new Book(); book.setId(1); book.setName(\"三国演义\"); book.setAuthor(\"罗贯中\"); Assertions.assertThat(jacksonTester.write(book)) .isEqualToJson(\"book.json\"); // Assertions.assertThat(jacksonTester.write(book)) // .hasJsonPathStringValue(\"@.name\"); // Assertions.assertThat(jacksonTester.write(book)) // .extractingJsonPathStringValue(\"@.name\") // .isEqualTo(\"book.json\"); } @Test public void testDeserialize() throws Exception { String content = \"{\\\"id\\\": 1, \\\"name\\\": \\\"三国演义\\\", \\\"author\\\": \\\"罗贯中\\\"}\"; Assertions.assertThat(jacksonTester.parseObject(content).getName()).isEqualTo(\"三国演义\"); } } "},"Java/SpringBoot+Vue开发实战笔记/chapter09.html":{"url":"Java/SpringBoot+Vue开发实战笔记/chapter09.html","title":"Chapter09","keywords":"","body":"第九章 Spring Boot 缓存 9.1 Ehcache 2.x 缓存 依赖 org.springframework.boot spring-boot-starter-cache net.sf.ehcache ehcache 缓存配置文件 src/main/resources/ehcache.xml 代码 实体类和Service @Repository @CacheConfig(cacheNames = \"book_cache\") public class BookDao { @Cacheable public Book getBookById(Integer id){ System.out.println(\"getBookById\"); Book book = new Book(); book.setId(id); book.setName(\"三国演义\"); book.setAuthor(\"罗贯中\"); return book; } @CachePut(key = \"#book.id\") public Book updateBookById(Book book) { System.out.println(\"updateBookById\"); book.setName(\"三国演义2\"); return book; } @CacheEvict(key = \"#id\") public void deleteBookById(Integer id) { System.out.println(\"deleteBookById\"); } } // Book.java public class Book implements Serializable { private Integer id; private String name; private String author; // 省略 } 开启缓存 @SpringBootApplication @EnableCaching public class Chapter09Application { public static void main(String[] args) { SpringApplication.run(Chapter09Application.class, args); } } 测试 开启@EnableCaching前： getBookById getBookById deleteBookById getBookById Book:Book{id=1, name='三国演义', author='罗贯中'} updateBookById getBookById b4:Book{id=1, name='三国演义', author='罗贯中'} 开启@EnableCaching后： getBookById --> 第二次get方法走了缓存没有打印 deleteBookById getBookById --> 调用删除后，缓存没了，这里执行 Book:Book{id=1, name='三国演义', author='罗贯中'} updateBookById --> 更新方法同时更新缓存，接下来get没打印 b4:Book{id=1, name='三国演义2', author='罗贯中'} 9.2 Redis 单机缓存 依赖 org.springframework.boot spring-boot-starter-cache org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-data-redis io.lettuce lettuce-core redis.clients jedis 缓存配置 #缓存的配置 ## 缓存的前置名 spring.cache.cache-names=c1,c2 ## 缓存的时间 spring.cache.redis.time-to-live=1800s #redis配置 ## redis有16库 spring.redis.database=0 ## redis的IP spring.redis.host=59.78.194.153 ## redis的端口 spring.redis.port=6378 ## redis的密码 spring.redis.password=123456 #redis的连接池最大连接数 spring.redis.jedis.pool.max-active=8 #redis的连接池中最大连接空闲数 spring.redis.jedis.pool.max-idle=8 #redis的连接池中最大等待时间，-1，表示没有限制 spring.redis.jedis.pool.max-wait=-1 #redis的连接池中最小连接空闲数 spring.redis.jedis.pool.min-idle=0 缓存 其他代码与测试与上一小结一致，测试成功： 9.3 Redis集群缓存 缓存配置 其余配置同第六章redis集群配置 //@Configuration 书上加了这个注解，实测加了会报错 public class RedisCacheConfig { @Autowired RedisConnectionFactory conFactory; @Bean RedisCacheManager redisCacheManager(){ Map configMap = new HashMap<>(); RedisCacheConfiguration redisConnection = RedisCacheConfiguration.defaultCacheConfig() .prefixKeysWith(\"ihao:\") .disableCachingNullValues() .entryTtl(Duration.ofMinutes(30)); configMap.put(\"c1\", redisConnection); RedisCacheWriter cacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(conFactory); RedisCacheManager redisCacheManager = new RedisCacheManager( cacheWriter, RedisCacheConfiguration.defaultCacheConfig(), configMap); return redisCacheManager; } } 代码 其余代码与上一下节一致 测试 getBookById book:这本书是三国演义 book2:这本书是三国演义 deleteBookById getBookById getBookById2 "},"Java/SpringBoot+Vue开发实战笔记/chapter10.html":{"url":"Java/SpringBoot+Vue开发实战笔记/chapter10.html","title":"Chapter10","keywords":"","body":"第十章 Spring Boot 安全管理 10.1 Spring Security 的基本配置 10.1.1 基本用法 依赖 org.springframework.boot spring-boot-starter-security 接口 @RestController public class HelloController { @GetMapping(\"hello\") public String hello() { return \"Hello\"; } } 测试 访问：http://localhost:8080/hello 自动跳转到登录页面 默认账户：user ， 密码： 登录成功后跳转到访问页。 10.1.2 配置用户名和密码 spring.security.user.name=ihao spring.security.user.password=123456 spring.security.user.roles=admin 10.1.3 基于内存的认证 @Configuration public class MyWebSecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder(){ return NoOpPasswordEncoder.getInstance(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"admin\").password(\"123456\").roles(\"ADMIN\", \"USER\") .and() .withUser(\"ihao\").password(\"123456\").roles(\"USER\"); } } 10.1.4 HttpSecurity @Configuration public class MyWebSecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder(){ return NoOpPasswordEncoder.getInstance(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"root\").password(\"123456\").roles(\"ADMIN\", \"DBA\") .and() .withUser(\"admin\").password(\"123456\").roles(\"ADMIN\", \"USER\") .and() .withUser(\"ihao\").password(\"123456\").roles(\"USER\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\") .hasRole(\"ADMIN\") .antMatchers(\"/user/**\") .access(\"hasAnyRole('ADMIN', 'USER')\") .antMatchers(\"/db/**\") .access(\"hasRole('ADMIN') and hasRole('DBA')\") .anyRequest() .authenticated() .and() .formLogin() .loginProcessingUrl(\"/login\") .permitAll() .and() .csrf() .disable(); } } @RestController public class HelloController { @GetMapping(\"/db/hello\") public String dba() { return \"hello dba!\"; } @GetMapping(\"/admin/hello\") public String admin() { return \"hello admin!\"; } @GetMapping(\"/user/hello\") public String user() { return \"hello user!\"; } } 以不同的账户登录，会有不同的访问权限 10.1.5 登录表单详细配置 代码 @Configuration public class MyWebSecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder(){ return NoOpPasswordEncoder.getInstance(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"root\").password(\"123456\").roles(\"ADMIN\", \"DBA\") .and() .withUser(\"admin\").password(\"123456\").roles(\"ADMIN\", \"USER\") .and() .withUser(\"ihao\").password(\"123456\").roles(\"USER\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\") .hasRole(\"ADMIN\") .antMatchers(\"/user/**\") .access(\"hasAnyRole('ADMIN', 'USER')\") .antMatchers(\"/db/**\") .access(\"hasRole('ADMIN') and hasRole('DBA')\") .anyRequest() .authenticated() .and() .formLogin() .loginPage(\"/login_page.html\") .loginProcessingUrl(\"/login\") .usernameParameter(\"name\") .passwordParameter(\"passwd\") .successHandler(new AuthenticationSuccessHandler() { @Override public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException { Object principal = authentication.getPrincipal(); httpServletResponse.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = httpServletResponse.getWriter(); httpServletResponse.setStatus(200); Map map = new HashMap<>(); map.put(\"status\", 200); map.put(\"msg\", principal); ObjectMapper om = new ObjectMapper(); out.write(om.writeValueAsString(map)); out.flush(); out.close(); } }) .failureHandler(new AuthenticationFailureHandler() { @Override public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException { httpServletResponse.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = httpServletResponse.getWriter(); httpServletResponse.setStatus(401); Map map = new HashMap<>(); map.put(\"status\", 401); if (e instanceof LockedException) { map.put(\"msg\", \"账户被锁定，登录失败\"); } else if (e instanceof BadCredentialsException) { map.put(\"msg\", \"账户名或密码输入错误，登录失败\"); } else if (e instanceof DisabledException) { map.put(\"msg\", \"账户被禁用，登录失败\"); } else if (e instanceof AccountExpiredException) { map.put(\"msg\", \"账户已过期，登录失败\"); } else if (e instanceof CredentialsExpiredException) { map.put(\"msg\", \"密码已过期，登录失败\"); } else { map.put(\"msg\", \"登录失败\"); } ObjectMapper om = new ObjectMapper(); out.write(om.writeValueAsString(map)); out.flush(); out.close(); } }) .permitAll() .and() .csrf() .disable(); } } 测试 10.1.7 注销登录配置 .and() .logout() .logoutUrl(\"/logout\") .clearAuthentication(true) .invalidateHttpSession(true) .addLogoutHandler(new LogoutHandler() { @Override public void logout(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) { } }) .logoutSuccessHandler(new LogoutSuccessHandler() { @Override public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException { httpServletResponse.sendRedirect(\"/login_page\"); } }) 10.1.8 密码加密 @Bean PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(10); } 生成加密后的密码： @Test void passwordEncoder() { BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(10); for (int i = 0; i 配置到配置代码中： @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"root\").password(\"$2a$10$u/l5bdTLrfC1v8wimLFgpuEdmxg.gpePiGkgqo1xgdZYGJ329.bN6\").roles(\"ADMIN\", \"DBA\") .and() .withUser(\"admin\").password(\"$2a$10$i/7kJguZi./hcLycAoG56.4YZ3VuU9AYgb8K98QZihKTyi32IfXSi\").roles(\"ADMIN\", \"USER\") .and() .withUser(\"ihao\").password(\"$2a$10$GHLUkkMBQNbpexWBNsH9MeCFXQllb5jYSAaRYD/6R9X0v7Z0DqQk.\").roles(\"USER\"); } 10.1.9 方法安全 配置 @Configuration @EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true) public class WebSecurityConfig { } // MyWebSecurityConfig.configure() 方法注射掉 服务 @Service public class MethodService { @Secured(\"ROLE_DBA\") public String dba() { return \"hello dba!\"; } @PreAuthorize(\"hasRole('ADMIN') or hasRole('DBA')\") public String admin() { return \"hello admin!\"; } @PreAuthorize(\"hasAnyRole('ADMIN', 'DBA', 'USER')\") public String user() { return \"hello user!\"; } } 控制层 @RestController public class HelloController { @Autowired MethodService methodService; @GetMapping(\"/db/hello\") public String dba() { return methodService.dba(); } @GetMapping(\"/admin/hello\") public String admin() { return methodService.admin(); } @GetMapping(\"/user/hello\") public String user() { return methodService.user(); } } 测试 访问：http://localhost:8080/admin/hello 需登录相应角色后有访问相应方法的权限 10.2 基于数据库的认证 设计数据表 CREATE TABLE `user` ( `id` INT(11) NOT NULL, `username` VARCHAR(32) NOT NULL DEFAULT '', `password` VARCHAR(255) NOT NULL DEFAULT '', `enabled` TINYINT NOT NULL DEFAULT 0, `locked` TINYINT NOT NULL DEFAULT 0, PRIMARY KEY (`id`) ) COMMENT='用户表' COLLATE='utf8mb4_unicode_ci' ; CREATE TABLE `user_role` ( `id` INT(11) NOT NULL, `uid` INT(11) NOT NULL, `rid` INT(11) NOT NULL, PRIMARY KEY (`id`) ) COLLATE='utf8mb4_unicode_ci' ; CREATE TABLE `role` ( `id` INT NOT NULL, `name` VARCHAR(32) NOT NULL DEFAULT '', `nameZh` VARCHAR(32) NOT NULL DEFAULT '', PRIMARY KEY (`id`) ) COLLATE='utf8mb4_unicode_ci' ; INSERT INTO `study`.`user` (`id`, `username`, `password`, `enabled`) VALUES ('1', 'root', '$2a$10$XIEXPUVI7KO7BHhcouwOkuGdGMCxrLeP3/4uquolM9.O81hpy7FUK', 'q'); /* SQL错误（1366）：Incorrect integer value: 'q' for column 'enabled' at row 1 */ INSERT INTO `study`.`user` (`id`, `username`, `password`, `enabled`) VALUES ('1', 'root', '$2a$10$XIEXPUVI7KO7BHhcouwOkuGdGMCxrLeP3/4uquolM9.O81hpy7FUK', '1'); SELECT `id`, `username`, `password`, `enabled`, `locked` FROM `study`.`user` WHERE `id`=1; INSERT INTO `study`.`user` (`id`, `username`, `password`, `enabled`) VALUES ('2', 'admin', '$2a$10$G/nzb3czQABEZy4HgEN7pu8KCRNgM076KGpsB7mU6nvdLnyEcPO.S', '1'); SELECT `id`, `username`, `password`, `enabled`, `locked` FROM `study`.`user` WHERE `id`=2; INSERT INTO `study`.`user` (`id`, `username`, `password`, `enabled`) VALUES ('3', 'ihao', '$2a$10$dRtaxlvje3y9rM40uHpFzeTVD/Ivaae6BMgTTxuYoiD35m16BSpx2', '1'); SELECT `id`, `username`, `password`, `enabled`, `locked` FROM `study`.`user` WHERE `id`=3; INSERT INTO `study`.`role` (`id`, `name`, `nameZh`) VALUES ('1', 'ROLE_dba', '数据库管理员'); SELECT `id`, `name`, `nameZh` FROM `study`.`role` WHERE `id`=1; INSERT INTO `study`.`role` (`id`, `name`, `nameZh`) VALUES ('2', 'ROLE_admin', '系统管理员'); SELECT `id`, `name`, `nameZh` FROM `study`.`role` WHERE `id`=2; INSERT INTO `study`.`role` (`id`, `name`, `nameZh`) VALUES ('3', 'ROLE_user', '用户'); SELECT `id`, `name`, `nameZh` FROM `study`.`role` WHERE `id`=3; INSERT INTO `study`.`user_role` (`id`, `uid`, `rid`) VALUES ('1', '1', '1'); SELECT `id`, `uid`, `rid` FROM `study`.`user_role` WHERE `id`=1; INSERT INTO `study`.`user_role` (`id`, `uid`, `rid`) VALUES ('2', '1', '2'); SELECT `id`, `uid`, `rid` FROM `study`.`user_role` WHERE `id`=2; INSERT INTO `study`.`user_role` (`id`, `uid`, `rid`) VALUES ('3', '2', '2'); SELECT `id`, `uid`, `rid` FROM `study`.`user_role` WHERE `id`=3; INSERT INTO `study`.`user_role` (`id`, `uid`, `rid`) VALUES ('4', '3', '3'); SELECT `id`, `uid`, `rid` FROM `study`.`user_role` WHERE `id`=4; 创建项目 org.springframework.boot spring-boot-starter-security org.mybatis.spring.boot mybatis-spring-boot-starter 1.3.2 mysql mysql-connector-java runtime com.alibaba druid 1.1.10 配置数据库 spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.url=jdbc:mysql://59.78.194.153:3306/study?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Hongkong spring.datasource.username=root spring.datasource.password=123456 实体类 public class Role { private Integer id; private String name; private String nameZh; // getter setter } public class User implements UserDetails { private Integer id; private String username; private String password; private Boolean enabled; private Boolean locked; private List roles; @Override public Collection getAuthorities() { List authorities = new ArrayList<>(); for (Role role : roles) { authorities.add(new SimpleGrantedAuthority(role.getName())); } return authorities; } @Override public String getPassword() { return password; } @Override public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return !locked; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return enabled; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public List getRoles() { return roles; } public void setRoles(List roles) { this.roles = roles; } // toString() { } 创建Service @Service public class UserService implements UserDetailsService { @Autowired UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { User user = userMapper.loadUserByUsername(username); System.out.println(\"user:\" + user); if (user == null) { throw new UsernameNotFoundException(\"账户不存在\"); } user.setRoles(userMapper.getUserRolesByUid(user.getId())); return user; } } Dao层 @Mapper public interface UserMapper { User loadUserByUsername(String username); List getUserRolesByUid(Integer id); } select * from user where username=#{username} select * from role r, user_role ur where r.id=ur.id and ur.id=#{id} 配置 Spring Security @Configuration public class MyWebSecurityConfig extends WebSecurityConfigurerAdapter { @Autowired UserService userService; @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(10); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userService); } } 测试 controller 层同前 10.4 OAuth 依赖 org.springframework.boot spring-boot-starter-security org.springframework.boot spring-boot-starter-data-redis io.lettuce lettuce-core redis.clients jedis org.springframework.security.oauth spring-security-oauth2 2.3.4.RELEASE 配置 Redis # REDIS (RedisProperties) # Redis数据库索引（默认为0） spring.redis.database=0 # Redis服务器地址 spring.redis.host=59.78.194.153 # Redis服务器连接端口 spring.redis.port=6378 # Redis服务器连接密码（默认为空） spring.redis.password=1xx # 连接池最大连接数（使用负值表示没有限制） spring.redis.pool.max-active=8 # 连接池最大阻塞等待时间（使用负值表示没有限制） spring.redis.pool.max-wait=-1 # 连接池中的最大空闲连接 spring.redis.pool.max-idle=8 # 连接池中的最小空闲连接 spring.redis.pool.min-idle=0 # 连接超时时间（毫秒） spring.redis.timeout=0 配置授权服务器 @Configuration @EnableAuthorizationServer public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { @Autowired AuthenticationManager authenticationManager; @Autowired RedisConnectionFactory redisConnectionFactory; @Autowired UserDetailsService userDetailsService; @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient(\"password\") .authorizedGrantTypes(\"password\", \"refresh_token\") .accessTokenValiditySeconds(1800) .resourceIds(\"rid\") .scopes(\"all\") .secret(\"$2a$10$dRtaxlvje3y9rM40uHpFzeTVD/Ivaae6BMgTTxuYoiD35m16BSpx2\"); } @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.tokenStore(new RedisTokenStore(redisConnectionFactory)) .authenticationManager(authenticationManager) .userDetailsService(userDetailsService); } @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security.allowFormAuthenticationForClients(); } } 配置资源服务器 @Configuration @EnableResourceServer public class ResourceServerConfig extends ResourceServerConfigurerAdapter { @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId(\"rid\").stateless(true); } @Override public void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"admin\") .antMatchers(\"/user/**\").hasRole(\"user\") .anyRequest().authenticated(); } } · 配置 Security @Configuration public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Bean(name = BeanIds.AUTHENTICATION_MANAGER) @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } @Bean @Override protected UserDetailsService userDetailsService() { return super.userDetailsService(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"admin\") .password(\"$2a$10$dRtaxlvje3y9rM40uHpFzeTVD/Ivaae6BMgTTxuYoiD35m16BSpx2\") .roles(\"admin\") .and() .withUser(\"ihao\") .password(\"$2a$10$dRtaxlvje3y9rM40uHpFzeTVD/Ivaae6BMgTTxuYoiD35m16BSpx2\") .roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.antMatcher(\"/oauth/**\").authorizeRequests() .antMatchers(\"/oauth/**\").permitAll() .and().csrf().disable(); } } 测试验证 post: http://localhost:8080/oauth/token?username=ihao&password=123456&grant_type=password&client_id=password&scope=all&client_secret=123456 { \"access_token\": \"518b32ac-6e46-4387-a3c5-467a47e28745\", \"token_type\": \"bearer\", \"refresh_token\": \"cefc0a87-7349-48cb-ace5-a7a7ab19581e\", \"expires_in\": 1799, \"scope\": \"all\" } post: http://localhost:8080/oauth/token?username=ihao&password=123456&grant_type=refresh_token&refresh_token=cefc0a87-7349-48cb-ace5-a7a7ab19581e&client_id=password&scope=all&client_secret=123456 { \"access_token\": \"bd00cf8b-0ad9-445e-92f5-1176b5fd8636\", \"token_type\": \"bearer\", \"refresh_token\": \"cefc0a87-7349-48cb-ace5-a7a7ab19581e\", \"expires_in\": 1799, \"scope\": \"all\" } get: http://localhost:8080/user/hello?access_token=bd00cf8b-0ad9-445e-92f5-1176b5fd8636 Hello user get: http://localhost:8080/admin/hello?access_token=bd00cf8b-0ad9-445e-92f5-1176b5fd8636 { \"error\": \"access_denied\", \"error_description\": \"Access is denied\" } reids： 10.5 整合 Shiro 依赖 org.apache.shiro shiro-spring-boot-web-starter 1.4.0 org.springframework.boot spring-boot-starter-thymeleaf com.github.theborakompanioni thymeleaf-extras-shiro 2.0.0 配置 配置文件 shiro.enabled=true shiro.web.enabled=true shiro.loginUrl=/login shiro.successUrl=/index shiro.unauthorizedUrl=/unauthorized shiro.sessionManager.sessionIdUrlRewritingEnabled=true shiro.sessionManager.sessionIdCookieEnabled=true 配置Shiro @Configuration public class ShiroConfig { @Bean public Realm realm() { TextConfigurationRealm realm = new TextConfigurationRealm(); realm.setUserDefinitions(\"ihao=123456,user\\n admin=123456,admin\"); //添加用户名+密码+角色 realm.setRoleDefinitions(\"admin=read,write\\n user=read\"); //添加权限 return realm; } @Bean public ShiroFilterChainDefinition shiroFilterChainDefinition() { DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition(); chainDefinition.addPathDefinition(\"/login\", \"anon\"); chainDefinition.addPathDefinition(\"/doLogin\", \"anon\"); chainDefinition.addPathDefinition(\"/logout\", \"logout\"); chainDefinition.addPathDefinition(\"/**\", \"authc\"); return chainDefinition; } @Bean public ShiroDialect shiroDialect() { return new ShiroDialect(); } } 不需要角色访问页面配置 @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/login\").setViewName(\"login\"); registry.addViewController(\"/index\").setViewName(\"index\"); registry.addViewController(\"/unauthorized\").setViewName(\"unauthorized\"); } } 配置全局异常处理 @ControllerAdvice public class ExceptionController { @ExceptionHandler(AuthorizationException.class) public ModelAndView error(AuthorizationException e) { ModelAndView mv = new ModelAndView(\"unauthorized\"); mv.addObject(\"error\", e.getMessage()); return mv; } } 控制层 @Controller public class UserController { @PostMapping(\"/doLogin\") public String doLogin(String username, String passwd, Model model) { // 记一个小坑： // username 和 passwd 两个参数接受的是来自login.html 中的 input 标签内的数据，名字需要对应 // 之前就是因为这里的参数名为 passwd login里提交的是password 害的密码一直验证出错 System.out.println(\"username:\" + username); System.out.println(\"passwd:\" + passwd); UsernamePasswordToken token = new UsernamePasswordToken(username, passwd); Subject subject = SecurityUtils.getSubject(); try { subject.login(token); } catch (AuthenticationException e) { model.addAttribute(\"error\", \"用户名或密码错误\"); return \"login\"; } return \"redirect:/index\"; } @RequiresRoles(\"admin\") @GetMapping(\"/admin\") public String admin() { return \"admin\"; } @RequiresRoles(value = {\"admin\", \"user\"}, logical = Logical.OR) @GetMapping(\"/user\") public String user() { return \"user\"; } } 添加五个HTML页面 index.html Title Hello, 注销登录 管理员页面 普通用户页面 login.html Title user.html Title 普通用户界面 admin.html Title 管理员界面 unauthorized.html Title 未获授权，非法访问 测试 "},"Java/SpringBoot+Vue开发实战笔记/chapter11.html":{"url":"Java/SpringBoot+Vue开发实战笔记/chapter11.html","title":"Chapter11","keywords":"","body":"第十一章 Spring Boot 整合 WebScoket 11.1 消息群发 依赖 org.springframework.boot spring-boot-starter-websocket org.webjars webjars-locator-core org.webjars sockjs-client 1.1.2 org.webjars stomp-websocket 2.3.3 org.webjars jquery 3.3.1 配置 WebSocket @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry config) { config.enableSimpleBroker(\"/topic\"); config.setApplicationDestinationPrefixes(\"/app\"); } @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint(\"/chat\").withSockJS(); } } 实体类 public class Message { private String name; private String content; } 控制层 @Controller public class GreetingController { @MessageMapping(\"/hello\") @SendTo(\"/topic/greetings\") public Message greeting(Message message) throws Exception { return message; } } 聊天页面 群聊 请输入用户名： 连接 断开连接 请输入聊天内容 发送 群聊进行中... 自定义JS var stompClient = null; function setConnected(connected) { $(\"#connect\").prop(\"disabled\", connected); $(\"#disconnect\").prop(\"disabled\", !connected); if (connected) { $(\"#conversation\").show(); $(\"#chat\").show(); } else { $(\"#conversation\").hide(); $(\"#chat\").hide(); } // $(\"#greetings\").html(\"\"); } function connect() { if (!$(\"#name\").val()) { return; } var socket = new SockJS(\"/chat\"); stompClient = Stomp.over(socket); stompClient.connect({}, function (frame) { setConnected(true); stompClient.subscribe(\"/topic/greetings\", function (greeting) { showGreeting(JSON.parse(greeting.body)); }); }); } function disconnect() { if (stompClient !== null) { stompClient.disconnect(); } setConnected(false); } function sendName() { console.log(\"sendName()...\") stompClient.send(\"/app/hello\", {}, JSON.stringify({'name': $(\"#name\").val(), 'content': $(\"#content\").val()})); } function showGreeting(message) { $(\"#greetings\") .append(\"\" + message.name + \":\" + message.content + \"\"); } $(function () { $(\"#connect\").click(function () { connect(); }); $(\"#disconnect\").click(function () { disconnect(); }); $(\"#send\").click(function () { sendName(); }); }); 测试 11.2 消息点对点发送 上一届基础上改进 依赖 org.springframework.boot spring-boot-starter-websocket org.webjars webjars-locator-core org.webjars sockjs-client 1.1.2 org.webjars stomp-websocket 2.3.3 org.webjars jquery 3.3.1 org.springframework.boot spring-boot-starter-security 配置 Spring Security 同第十章的内容 @Configuration public class MyWebSecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder(){ return NoOpPasswordEncoder.getInstance(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"admin\").password(\"123456\").roles(\"ADMIN\", \"USER\") .and() .withUser(\"ihao\").password(\"123456\").roles(\"USER\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest() .authenticated() .and() .formLogin() .permitAll(); } } 配置 WebSocket @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry config) { config.enableSimpleBroker(\"/topic\", \"/queue\"); config.setApplicationDestinationPrefixes(\"/app\"); } @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint(\"/chat\").withSockJS(); } } 实体类 public class Chat { private String to; private String from; private String content; } 控制层 @Controller public class GreetingController { @Autowired SimpMessagingTemplate messagingTemplate; @MessageMapping(\"/hello\") @SendTo(\"/topic/greetings\") public Message greeting(Message message) throws Exception { return message; } @MessageMapping(\"/chat\") public void chat(Principal principal, Chat chat) { String from = principal.getName(); chat.setFrom(from); messagingTemplate.convertAndSendToUser(chat.getTo(), \"/queue/chat\", chat); } } 页面 单聊 请输入聊天内容： 目标用户： 发送 var stompClient = null; function connect() { var socket = new SockJS(\"/chat\"); stompClient = Stomp.over(socket); stompClient.connect({}, function (frame) { stompClient.subscribe(\"/user/queue/chat\", function (chat) { showGreeting(JSON.parse(chat.body)); }); }); } function sendMsg() { stompClient.send(\"/app/chat\", {}, JSON.stringify({'content': $(\"#content\").val(), 'to': $(\"#to\").val()})); } function showGreeting(message) { $(\"#chatsContent\").append(\"\" + message.from + \":\" + message.content + \"\"); } $(function () { connect(); $(\"#send\").click(function () { sendMsg(); }); }); 测试 登录配置的两个账户 "},"Java/SpringBoot+Vue开发实战笔记/chapter12.html":{"url":"Java/SpringBoot+Vue开发实战笔记/chapter12.html","title":"Chapter12","keywords":"","body":"第十二章 消息服务 12.1 JMS-ActiveMQ docker下安装ActiveMQ https://developer.aliyun.com/article/572390 查询Docker镜像 docker search activemq 下载Docker镜像 docker pull webcenter/activemq 创建&运行ActiveMQ容器 docker run -d --name myactivemq -p 61616:61616 -p 8161:8161 webcenter/activemq 查看WEB管理页面： 浏览器输入http://127.0.0.1:8161/，点击Manage ActiveMQ broker使用默认账号/密码：admin/admin进入查看 依赖 org.springframework.boot spring-boot-starter-activemq 配置 spring.activemq.broker-url=tcp://59.78.194.153:61616 spring.activemq.packages.trust-all=true spring.activemq.user=admin spring.activemq.password=admin 项目配置类 提供一个消息队列Bean import javax.jms.Queue; @SpringBootApplication public class Chapter12Application { public static void main(String[] args) { SpringApplication.run(Chapter12Application.class, args); } @Bean Queue queue() { return new ActiveMQQueue(\"amq\"); } } JMS 组件 @Component public class JmsComponent { @Autowired JmsMessagingTemplate messagingTemplate; @Autowired Queue queue; public void send(Message msg) { messagingTemplate.convertAndSend(this.queue, msg); } @JmsListener(destination = \"amq\") public void receive(Message msg) { System.out.println(\"receive:\" + msg); } } 实体类 public class Message implements Serializable { private String content; private Date date; } 测试 @SpringBootTest class Chapter12ApplicationTests { @Autowired JmsComponent jmsComponent; @Test void contextLoads() { Message msg = new Message(); msg.setContent(\"hello jsm!\"); msg.setDate(new Date()); jmsComponent.send(msg); } } 运行后输出： receive:Message{content='hello jsm!', date=Sat Dec 19 20:11:02 CST 2020} 12.2 AMQP-RabbitMQ docker安装 RabbitMQ https://www.jianshu.com/p/14ffe0f3db94 这里注意获取镜像的时候要获取management版本的，不要获取last版本的，management版本的才带有管理界面。 获查询镜像 docker search rabbitmq:management 获取镜像 docker pull rabbitmq:management 可以看到如下结果 [hzh@localhost ~]$ docker pull rabbitmq:management management: Pulling from library/rabbitmq f22ccc0b8772: Pull complete 3cf8fb62ba5f: Pull complete e80c964ece6a: Pull complete c1d2d6c5864b: Pull complete a1d14468c24f: Pull complete ac5224ea1eb3: Pull complete 8da622546a6c: Pull complete 5f20211ad28c: Pull complete 553fbbbec0d8: Pull complete 87e159513515: Pull complete e7ad102c950f: Pull complete fc664c88ed06: Pull complete 4c05edd7de3b: Pull complete Digest: sha256:83fb3d109a3775bd8bc38629864bf54c074c41c5e34b608987b0b524ba707aff Status: Downloaded newer image for rabbitmq:management docker.io/library/rabbitmq:management 运行镜像 [hzh@localhost ~]$ docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq rabbitmq:management 57600974b4423618a9339d75212bba4770231e4b9605c81c8f73d53a7d4567f8 访问管理界面 访问管理界面的地址就是 http://59.78.194.153:15672，可以使用默认的账户登录，用户名和密码都guest，如： 新建用户 默认 guest 用户，新建一个自己的可远程登录的用户 Spring Boot 整合 RabbitMQ 依赖 org.springframework.boot spring-boot-starter-amqp 配置 spring.rabbitmq.host=59.78.194.153 spring.rabbitmq.port=5672 spring.rabbitmq.username=ihao spring.rabbitmq.password=123456 Direct 策略 策略配置 @Configuration public class RabbitDirectConfig { public final static String DIRECTNAME = \"ihao-direct\"; @Bean Queue queue() { return new Queue(\"hello-queue\"); } @Bean DirectExchange directExchange() { return new DirectExchange(DIRECTNAME, true, false); } @Bean Binding binding() { return BindingBuilder.bind(queue()) .to(directExchange()).with(\"direct\"); } } 配置消费者 @Component public class DirectReceiver { @RabbitListener(queues = \"hello-queue\") public void handler1(String msg) { System.out.println(\"DirectReceiver:\" + msg); } } 测试 @SpringBootTest class Chapter12ApplicationTests { @Autowired JmsComponent jmsComponent; @Test void contextLoads() { Message msg = new Message(); msg.setContent(\"hello jsm!\"); msg.setDate(new Date()); jmsComponent.send(msg); } } // 输出 // DirectReceiver:hello direct Fanout 策略 策略配置 @Configuration public class RabbitFanoutConfig { public final static String FANOUTNAME = \"ihao-fanout\"; @Bean FanoutExchange fanoutExchange() { return new FanoutExchange(FANOUTNAME, true, false); } @Bean Queue queueOne() { return new Queue(\"queue-one\"); } @Bean Queue queueTwo() { return new Queue(\"queue-two\"); } @Bean Binding bindingOne() { return BindingBuilder.bind(queueOne()).to(fanoutExchange()); } @Bean Binding bindingTwo() { return BindingBuilder.bind(queueTwo()).to(fanoutExchange()); } } 消费者 @Component public class FanoutReceiver { @RabbitListener(queues = \"queue-one\") public void handler1(String msg) { System.out.println(\"FanoutReceiver:handler1:\" + msg); } @RabbitListener(queues = \"queue-two\") public void handler2(String msg) { System.out.println(\"FanoutReceiver:handler2:\" + msg); } } 测试 @Test void fanoutReceiverTest() { rabbitTemplate.convertAndSend(RabbitFanoutConfig.FANOUTNAME, null, \"hello fanout!\"); } // 输出 FanoutReceiver:handler1:hello fanout! FanoutReceiver:handler2:hello fanout! Topic 策略 策略配置 @Configuration public class RabbitTopicConfig { public final static String TOPICNAME = \"ihao-topic\"; @Bean TopicExchange topicExchange() { return new TopicExchange(TOPICNAME, true, false); } @Bean Queue xiaomi() { return new Queue(\"xiaomi\"); } @Bean Queue huawei() { return new Queue(\"huawei\"); } @Bean Queue phone() { return new Queue(\"phone\"); } @Bean Binding xiaomiBinding() { return BindingBuilder.bind(xiaomi()).to(topicExchange()).with(\"xiaomi.#\"); } @Bean Binding huaweiBinding() { return BindingBuilder.bind(huawei()).to(topicExchange()).with(\"huawei.#\"); } @Bean Binding phoneBinding() { return BindingBuilder.bind(phone()).to(topicExchange()).with(\"#.phone.#\"); } } 消费者 @Component public class TopicReceiver { @RabbitListener(queues = \"xiaomi\") public void handler1(String msg) { System.out.println(\"xiaomiReceiver:\" + msg); } @RabbitListener(queues = \"huawei\") public void handler2(String msg) { System.out.println(\"huaweiReceiver:\" + msg); } @RabbitListener(queues = \"phone\") public void handler3(String msg) { System.out.println(\"phoneReceiver:\" + msg); } } 测试 @Test void topicReceiverTest() { rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME, \"xiaomi.news\", \"小米新闻...\"); rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME, \"huawei.news\", \"华为新闻...\"); rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME, \"xiaomi.phone\", \"小米手机...\"); rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME, \"huawei.phone\", \"华为手机...\"); rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME, \"phone.news\", \"手机新闻...\"); } // 输出 huaweiReceiver:华为新闻... xiaomiReceiver:小米新闻... phoneReceiver:小米手机... phoneReceiver:华为手机... xiaomiReceiver:小米手机... huaweiReceiver:华为手机... phoneReceiver:手机新闻... header 策略 策略配置 @Configuration public class RabbitHeaderConfig { public final static String HEADERNAME = \"ihao-header\"; @Bean HeadersExchange headersExchange() { return new HeadersExchange(HEADERNAME, true, false); } @Bean Queue queueName() { return new Queue(\"name-queue\"); } @Bean Queue queueAge() { return new Queue(\"age-queue\"); } @Bean Binding BindingName() { Map map = new HashMap<>(); map.put(\"name\", \"ihao\"); return BindingBuilder.bind(queueName()).to(headersExchange()).whereAny(map).match(); } @Bean Binding BindingAge() { return BindingBuilder.bind(queueAge()).to(headersExchange()).where(\"age\").exists(); } } 消费者 @Component public class HeaderReceiver { @RabbitListener(queues = \"name-queue\") public void handler1(byte[] msg) { System.out.println(\"HeaderReceiver:name:\" + new String(msg, 0, msg.length)); } @RabbitListener(queues = \"age-queue\") public void handler2(byte[] msg) { System.out.println(\"HeaderReceiver:age:\" + new String(msg, 0, msg.length)); } } 测试 @Test void headerReceiverTest() { Message nameMsg = MessageBuilder.withBody(\"hello header! name-queue\".getBytes()) .setHeader(\"name\", \"ihao\").build(); Message ageMsg = MessageBuilder.withBody(\"hello header! age-queue\".getBytes()) .setHeader(\"age\", \"19\").build(); rabbitTemplate.send(RabbitHeaderConfig.HEADERNAME, null, nameMsg); rabbitTemplate.send(RabbitHeaderConfig.HEADERNAME, null, ageMsg); } // 输出 HeaderReceiver:age:hello header! age-queue HeaderReceiver:name:hello header! name-queue "},"Java/SpringBoot+Vue开发实战笔记/chapter13.html":{"url":"Java/SpringBoot+Vue开发实战笔记/chapter13.html","title":"Chapter13","keywords":"","body":"第十三章 企业开发 13.1 邮件发送 依赖 org.springframework.boot spring-boot-starter-mail 配置 spring.mail.host=smtp.qq.com spring.mail.port=587 spring.mail.username=8722xxx@qq.com spring.mail.password=naxxxxxxfb spring.mail.default-encoding=UTF-8 spring.mail.properties.mail.socketFactory.class=javax.net.ssl.SSLSocketFactory spring.mail.properties.mail.debug=true 发送简单邮件 服务类 @Component public class MailService { @Autowired JavaMailSender javaMailSender; public void sendSimpleMail(String from, String to, String cc, String subject, String content) { SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); simpleMailMessage.setFrom(from); simpleMailMessage.setTo(to); simpleMailMessage.setCc(cc); simpleMailMessage.setSubject(subject); simpleMailMessage.setText(content); javaMailSender.send(simpleMailMessage); } } 测试 @SpringBootTest class Chapter13ApplicationTests { @Autowired MailService mailService; @Test void sendMailTest() { mailService.sendSimpleMail(\"8xxx@qq.com\", \"5xxx@qq.com\", \"hzxxx@163.com\", \"邮件测试主题\", \"邮件测试内容\"); } } 发送带附件邮件 服务类 @Component public class MailService { @Autowired JavaMailSender javaMailSender; public void sendAttachFileMail(String from, String to, String subject, String content, File file) { try { MimeMessage message = javaMailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content); helper.addAttachment(file.getName(), file); javaMailSender.send(message); } catch (MessagingException e) { e.printStackTrace(); } } } 测试 @Test void sendAttachFileMailTest() { mailService.sendAttachFileMail(\"8qq.com\", \"5@qq.com\", \"邮件测试主题\", \"邮件测试内容\", new File(\"D:\\\\研究.docx\")); } 发送带图片资源邮件 服务类 public void sendMailWithImg(String from, String to, String subject, String content, String[] srcPath, String[] resIds) { if (srcPath.length != resIds.length) { System.out.println(\"发送失败\"); return; } try { MimeMessage message = javaMailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); for (int i = 0; i 测试 @Test void sendMailWithImgTest() { mailService.sendMailWithImg(\"8@qq.com\", \"5@qq.com\", \"图片邮件测试主题\", \" 这是一封带图片的邮件：\" + \"这是图片1：\" + \"这是图片2：\" + \"\", new String[]{\"D:\\\\1.png\", \"D:\\\\2.png\"}, new String[]{\"p01\", \"p02\"}); } 使用 FerrMarker 构建邮件模板 依赖 org.springframework.boot spring-boot-starter-freemarker 服务 public void sendHtmlMail(String from, String to, String subject, String content) { try { MimeMessage message = javaMailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); javaMailSender.send(message); } catch (MessagingException e) { System.out.println(\"发送失败\"); e.printStackTrace(); } } 邮件模板 src/main/resources/ftl/mailtemplate.ftl 邮箱激活 您的注册信息是： 用户名 ${username} 用户性别 ${gender} 核对无误请点击本链接激活邮箱 实体类 public class User { private String username; private String gender; } 测试 @Test void sendHtmlMail() { try { Configuration configuration = new Configuration(Configuration.VERSION_2_3_0); ClassLoader loader = Chapter13Application.class.getClassLoader(); configuration.setClassLoaderForTemplateLoading(loader, \"ftl\"); Template template = configuration.getTemplate(\"mailtemplate.ftl\"); StringWriter mail = new StringWriter(); User user = new User(); user.setGender(\"男\"); user.setUsername(\"ihaozz\"); template.process(user, mail); mailService.sendHtmlMail(\"8@qq.com\", \"5@qq.com\", \"sendHtmlMail邮件测试主题\", mail.toString()); } catch (Exception e) { e.printStackTrace(); } } 使用 Thymeleaf 构建邮件模板 依赖 org.springframework.boot spring-boot-starter-thymeleaf 模板 templates/mailtemplate.html 邮件 邮箱激活 您的注册信息是： 用户名 用户性别 核对无误请点击本链接激活邮箱 测试 @Autowired TemplateEngine templateEngine; @Test void sendHtmlMailThymeleaf() { Context ctx = new Context(); ctx.setVariable(\"username\", \"ihaozz\"); ctx.setVariable(\"gender\", \"男\"); String mail = templateEngine.process(\"mailtemplate.html\", ctx); mailService.sendHtmlMail(\"8@qq.com\", \"5@qq.com\", \"sendHtmlMailThymeleaf邮件测试主题\", mail); } 13.2 定时任务 @Scheduled 依赖 spring-boot-starter-web 开启定时任务 @SpringBootApplication @EnableScheduling public class Chapter13Application { public static void main(String[] args) { SpringApplication.run(Chapter13Application.class, args); } } 配置定时任务 @Component public class MySchedule { @Scheduled(fixedDelay = 1000) public void fixedDelay() { System.out.println(\"fixedDelay:\" + new Date()); } @Scheduled(fixedRate = 2000) public void fixedRate() { System.out.println(\"fixedRate:\" + new Date()); } @Scheduled(initialDelay = 1000, fixedRate = 2000) public void initialDelay() { System.out.println(\"initialDelay:\" + new Date()); } @Scheduled(cron = \"0 * * * * ?\") public void cron() { System.out.println(\"cron:\" + new Date()); } } 测试 运行项目 fixedRate:Mon Dec 21 19:33:31 CST 2020 fixedDelay:Mon Dec 21 19:33:31 CST 2020 initialDelay:Mon Dec 21 19:33:32 CST 2020 fixedDelay:Mon Dec 21 19:33:32 CST 2020 fixedRate:Mon Dec 21 19:33:33 CST 2020 fixedDelay:Mon Dec 21 19:33:33 CST 2020 initialDelay:Mon Dec 21 19:33:34 CST 2020 fixedDelay:Mon Dec 21 19:33:34 CST 2020 fixedRate:Mon Dec 21 19:33:35 CST 2020 fixedDelay:Mon Dec 21 19:33:35 CST 2020 initialDelay:Mon Dec 21 19:33:36 CST 2020 ... ... Quartz 依赖 org.springframework.boot spring-boot-starter-quartz 创建Job @Component public class MyFirstJob { public void sayHello() { System.out.println(\"MyFirstJob:sayHello:\" + new Date()); } } public class MySecondJob extends QuartzJobBean { private String name; public void setName(String name) { this.name = name; } @Override protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException { System.out.println(\"hello:\" + name + \":\" + new Date()); } } 配置 @Configuration public class QuartzConfig { @Bean MethodInvokingJobDetailFactoryBean jobDetail1() { MethodInvokingJobDetailFactoryBean bean = new MethodInvokingJobDetailFactoryBean(); bean.setTargetBeanName(\"myFirstJob\"); bean.setTargetMethod(\"sayHello\"); return bean; } @Bean JobDetailFactoryBean jobDetail2() { JobDetailFactoryBean bean = new JobDetailFactoryBean(); bean.setJobClass(MySecondJob.class); JobDataMap jobDataMap = new JobDataMap(); jobDataMap.put(\"name\", \"ihao\"); bean.setJobDataMap(jobDataMap); bean.setDurability(true); return bean; } @Bean SimpleTriggerFactoryBean simpleTrigger() { SimpleTriggerFactoryBean bean = new SimpleTriggerFactoryBean(); bean.setJobDetail(jobDetail1().getObject()); bean.setRepeatCount(3); bean.setStartDelay(1000); bean.setRepeatInterval(2000); return bean; } @Bean CronTriggerFactoryBean cronTrigger() { CronTriggerFactoryBean bean = new CronTriggerFactoryBean(); bean.setJobDetail(jobDetail2().getObject()); bean.setCronExpression(\"* * * * * ?\"); return bean; } @Bean SchedulerFactoryBean schedulerFactory() { SchedulerFactoryBean bean = new SchedulerFactoryBean(); SimpleTrigger simpleTrigger = simpleTrigger().getObject(); CronTrigger cronTrigger = cronTrigger().getObject(); bean.setTriggers(simpleTrigger, cronTrigger); return bean; } } 运行 hello:ihao:Mon Dec 21 20:18:54 CST 2020 hello:ihao:Mon Dec 21 20:18:55 CST 2020 MyFirstJob:sayHello:Mon Dec 21 20:18:55 CST 2020 hello:ihao:Mon Dec 21 20:18:56 CST 2020 hello:ihao:Mon Dec 21 20:18:57 CST 2020 MyFirstJob:sayHello:Mon Dec 21 20:18:57 CST 2020 hello:ihao:Mon Dec 21 20:18:58 CST 2020 hello:ihao:Mon Dec 21 20:18:59 CST 2020 MyFirstJob:sayHello:Mon Dec 21 20:18:59 CST 2020 hello:ihao:Mon Dec 21 20:19:00 CST 2020 hello:ihao:Mon Dec 21 20:19:01 CST 2020 MyFirstJob:sayHello:Mon Dec 21 20:19:01 CST 2020 hello:ihao:Mon Dec 21 20:19:02 CST 2020 hello:ihao:Mon Dec 21 20:19:03 CST 2020 hello:ihao:Mon Dec 21 20:19:04 CST 2020 hello:ihao:Mon Dec 21 20:19:05 CST 2020 hello:ihao:Mon Dec 21 20:19:06 CST 2020 hello:ihao:Mon Dec 21 20:19:07 CST 2020 Process finished with exit code -1 13.3 批处理 依赖 org.springframework.boot spring-boot-starter-batch org.springframework.boot spring-boot-starter-jdbc com.alibaba druid 1.1.10 mysql mysql-connector-java 配置 spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.url=jdbc:mysql://59.7xxx:3306/study?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Hongkong spring.datasource.username=root spring.datasource.password=123456 spring.datasource.schema=classpath:/org/springframework/batch/core/schema-mysql.sql spring.batch.initialize-schema=always spring.batch.job.enabled=false 开启注解 @SpringBootApplication @EnableBatchProcessing public class Chapter13Application { public static void main(String[] args) { SpringApplication.run(Chapter13Application.class, args); } } 配置批处理 @Configuration public class CsvBatchJobConfig { @Autowired JobBuilderFactory jobBuilderFactory; @Autowired StepBuilderFactory stepBuilderFactory; @Autowired DataSource dataSource; @Bean @StepScope FlatFileItemReader itemReader() { FlatFileItemReader reader = new FlatFileItemReader<>(); reader.setLinesToSkip(1); reader.setResource(new ClassPathResource(\"data.csv\")); reader.setEncoding(\"utf-8\"); reader.setLineMapper(new DefaultLineMapper(){{ setLineTokenizer(new DelimitedLineTokenizer(){{ setNames(\"id\", \"username\", \"address\", \"gender\"); setDelimiter(\",\"); }}); setFieldSetMapper(new BeanWrapperFieldSetMapper(){{ setTargetType(User.class); }}); }}); return reader; } @Bean JdbcBatchItemWriter jdbcBatchItemWriter() { JdbcBatchItemWriter writer = new JdbcBatchItemWriter(); writer.setDataSource(dataSource); writer.setSql(\"insert into user(id,username,address,gender) \" + \"values(:id,:username,:address,:gender)\"); writer.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>()); return writer; } @Bean Step csvStep() { return stepBuilderFactory.get(\"csvStep\") .chunk(2) .reader(itemReader()) .writer(jdbcBatchItemWriter()) .build(); } @Bean Job csvJob() { return jobBuilderFactory.get(\"csvJob\") .start(csvStep()) .build(); } } 实体类 public class User { private Integer id; private String username; private String address; private String gender; } 建表 CREATE TABLE `user` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `username` VARCHAR(32) NOT NULL DEFAULT '' COMMENT '姓名', `address` VARCHAR(64) NOT NULL DEFAULT '' COMMENT '地址', `gender` VARCHAR(16) NOT NULL DEFAULT '' COMMENT '性别', PRIMARY KEY (`id`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=1; 控制层 @RestController public class HelloController { @Autowired JobLauncher jobLauncher; @Autowired Job job; @GetMapping(\"/hello\") public void hello() { try { jobLauncher.run(job, new JobParametersBuilder().toJobParameters()); } catch (Exception e) { e.printStackTrace(); } } } 测试 访问：http://localhost:8080/hello 13.4 Swagger 2 依赖 io.springfox springfox-swagger2 2.9.2 io.springfox springfox-swagger-ui 2.9.2 配置类 @Configuration @EnableSwagger2 public class SwagerConfig { @Bean Docket docket() { return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.basePackage(\"top.huzhenhao.chapter13.controller\")) .paths(PathSelectors.any()) .build().apiInfo(new ApiInfoBuilder() .description(\"接口测试文档\") .contact(new Contact(\"ihao\", \"https://huzhenhao.top\", \"hzh_aj@163.com\")) .version(\"v1.0\") .title(\"API 测试文档\") .license(\"Apache2.0\") .licenseUrl(\"http://www.apache.org/licenses/LICENSE-2.0\") .build()); } } 控制层接口 @RestController @Api(tags = \"用户数据接口\") public class UserController { @ApiOperation(value = \"查询用户\", notes = \"根据id查询用户\") @ApiImplicitParam(paramType = \"path\", name = \"id\", value = \"用户id\", readOnly = true) @GetMapping(\"/user/{id}\") public String getUserById(@PathVariable Integer id) { return \"/user/\" + id; } @ApiResponses({ @ApiResponse(code = 200, message = \"删除成功\"), @ApiResponse(code = 500, message = \"删除失败\") }) @ApiOperation(value = \"删除用户\", notes = \"通过id删除用户\") @DeleteMapping(\"/user/{id}\") public Integer deleteUserById(@PathVariable Integer id) { return id; } @ApiOperation(value = \"添加用户\", notes = \"添加一个用户，传入用户名和地址\") @ApiImplicitParams({ @ApiImplicitParam(paramType = \"query\", name = \"username\", value = \"用户名\", readOnly = true, defaultValue = \"ihao\"), @ApiImplicitParam(paramType = \"query\", name = \"address\", value = \"用户地址\", readOnly = true, defaultValue = \"上海\") }) @PostMapping(\"/user\") public String addUser(@RequestParam String username, @RequestParam String address) { return username + \":\" + address; } @ApiOperation(value = \"修改用户\", notes = \"修改用户，传入用户信息\") @PutMapping(\"/user\") public String updateUser(@RequestBody User user) { return user.toString(); } @GetMapping(\"/ignore\") @ApiIgnore public void ignoreMethod(){} } 实体类 @ApiModel(value = \"用户实体类\", description = \"用户信息描述类\") public class User { private Integer id; @ApiModelProperty(value = \"用户名\") private String username; @ApiModelProperty(value = \"用户地址\") private String address; private String gender; } 运行 http://localhost:8080/swagger-ui.html 13.5 数据校验 普通校验 依赖 org.springframework.boot spring-boot-starter-validation 配置校验 src/main/resources/ValidationMessages.properties user.name.size=用户名长度介于5到10个字符之间 user.address.notnull=用户地址不能为空 user.age.size=年龄输入不正确 user.email.notnull=邮箱不能为空 user.email.pattern=邮箱格式不正确 配置实体类 public class User { private Integer id; @Size(min = 5, max = 10, message = \"{user.name.size}\") private String username; @NotNull(message = \"{user.address.notnull}\") private String address; @DecimalMin(value = \"1\", message = \"{user.age.size}\") @DecimalMax(value = \"200\", message = \"{user.age.size}\") private Integer age; @Email(message = \"{user.email.pattern}\") @NotNull(message = \"{user.email.notnull}\") private String email; } 控制层 @PostMapping(\"/adduser\") public List addUser(@Validated User user, BindingResult result) { List errors = new ArrayList<>(); if (result.hasErrors()) { List addErrors = result.getAllErrors(); for (ObjectError error : addErrors) { errors.add(error.getDefaultMessage()); } } return errors; } 测试 post http://localhost:8080/adduser http://localhost:8080/adduser?username=ihao&address=上海&email=123 分组校验 分组接口 public interface ValidationGroup1 { } public interface ValidationGroup2 { } 添加分组信息 public class User { private Integer id; @Size(min = 5, max = 10, message = \"{user.name.size}\", groups = ValidationGroup1.class) private String username; @NotNull(message = \"{user.address.notnull}\", groups = ValidationGroup2.class) private String address; @DecimalMin(value = \"1\", message = \"{user.age.size}\") @DecimalMax(value = \"200\", message = \"{user.age.size}\") private Integer age; @Email(message = \"{user.email.pattern}\") @NotNull(message = \"{user.email.notnull}\", groups = {ValidationGroup1.class, ValidationGroup2.class}) private String email; } 指定校验分组 @PostMapping(\"/adduser\") public List addUser(@Validated(ValidationGroup2.class) User user, BindingResult result) { List errors = new ArrayList<>(); if (result.hasErrors()) { List addErrors = result.getAllErrors(); for (ObjectError error : addErrors) { errors.add(error.getDefaultMessage()); } } return errors; } 测试 只验证 ValidationGroup2，即用户地址、邮箱是否为空 校验注解 javax.validation.constraints "},"Java/代码段.html":{"url":"Java/代码段.html","title":"代码段","keywords":"","body":"代码段 单例模式 public class Singleton { private Singleton instance; public Singleton Singleton() { if (instance == null){ synchronized (Singleton.class){ if (instance == null){ instance = new Singleton(); } } } return instance; } } 策略设计模式 继承实现 import java.util.*; class Processor { public String name() { return getClass().getSimpleName(); } public Object process(Object input) { return input; } } class Upcase extends Processor { // 返回协变类型 @Override public String process(Object input) { return ((String) input).toUpperCase(); } } class Downcase extends Processor { @Override public String process(Object input) { return ((String) input).toLowerCase(); } } class Splitter extends Processor { @Override public String process(Object input) { // split() divides a String into pieces: return Arrays.toString(((String) input).split(\" \")); } } public class Applicator { public static void apply(Processor p, Object s) { System.out.println(\"Using Processor \" + p.name()); System.out.println(p.process(s)); } public static void main(String[] args) { String s = \"We are such stuff as dreams are made on\"; apply(new Upcase(), s); apply(new Downcase(), s); apply(new Splitter(), s); } } // 输出 Using Processor Upcase WE ARE SUCH STUFF AS DREAMS ARE MADE ON Using Processor Downcase we are such stuff as dreams are made on Using Processor Splitter [We, are, such, stuff, as, dreams, are, made, on] 用接口解耦 public class Applicator { public static void apply(Processor p, Object s) { System.out.println(\"Using Processor \" + p.name()); System.out.println(p.process(s)); } /* public static void main(String[] args) { String S = // [2] \"If she weighs the same as a duck, \" + \"she's made of wood\"; Applicator.apply(new Upcase(), S); Applicator.apply(new Downcase(), S); Applicator.apply(new Splitter(), S); }*/ } public interface Processor { default String name() { return getClass().getSimpleName(); } Object process(Object input); String S = // S 自动就是 final 和 static 的，因为它是在接口中定义的。 \"If she weighs the same as a duck, \" + \"she's made of wood\"; static void main(String[] args) { // 可以在接口中定义 main() 方法。 Applicator.apply(new Upcase(), S); Applicator.apply(new Downcase(), S); Applicator.apply(new Splitter(), S); } } class Upcase implements StringProcessor { @Override // Covariant return: public String process(Object input) { return ((String)input).toUpperCase(); } } class Downcase implements StringProcessor { @Override public String process(Object input) { return ((String)input).toLowerCase(); } } class Splitter implements StringProcessor { @Override public String process(Object input) { return Arrays.toString(((String)input).split(\" \")); } } /* Output: Using Processor Upcase IF SHE WEIGHS THE SAME AS A DUCK, SHE'S MADE OF WOOD Using Processor Downcase if she weighs the same as a duck, she's made of wood Using Processor Splitter [If, she, weighs, the, same, as, a, duck,, she's, made, of, wood] */ 死锁 public class DeadLockDemo { static Object l1 = new Object(); static Object l2 = new Object(); public static void main(String[] args) { new Thread(() -> { synchronized (l1) { System.out.println(\"Thead 1 获取资源1\"); try { Thread.sleep(1000); System.out.println(\"Thead 1 do something step 1\"); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thead 1 尝试获取资源2...\"); synchronized (l2){ System.out.println(\"Thead 1 获取资源2\"); } System.out.println(\"Thead 1 do something step 2\"); } }).start(); new Thread(() -> { synchronized (l2) { System.out.println(\"Thead 2 获取资源2\"); try { Thread.sleep(1000); System.out.println(\"Thead 2 do something step 1\"); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thead 2 尝试获取资源1...\"); synchronized (l1){ System.out.println(\"Thead 2 获取资源1\"); } System.out.println(\"Thead 2 do something step 2\"); } }).start(); System.out.println(\"执行完毕！\"); } } 破坏互斥条件 这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。 破坏请求与保持条件 一次性申请所有的资源。 破坏不剥夺条件 占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。 破坏循环等待条件 靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。 "},"Python/基础.html":{"url":"Python/基础.html","title":"Python基础","keywords":"","body":"Python基础 文件 读取文件 files = [] filePath = '../爬虫/课程评价/' for file in os.listdir(filePath): if str(file)[-8:] == 'ment.csv': files.append(file) print(files[:5]) CSV转TXT for file in files: data = pd.read_csv(filePath+file, encoding='utf-8', header=None, engine='python') with open('filename.txt','a+', encoding='utf-8') as f: for line in data.values: f.write((str(line[0])+'\\t'+str(line[1])+'\\n')) # 对应csv数据字段 判断目录是否存在 import os dirs = '/Users/joseph/work/python/' if not os.path.exists(dirs): os.makedirs(dirs) 判断文件是否存在 import os filename = '/Users/joseph/work/python/poem.txt' if not os.path.exists(filename): os.system(r\"touch {}\".format(path)) #调用系统命令行来创建文件 原文链接：https://blog.csdn.net/u013247765/article/details/79050947 字典 字典排序 freq = sorted(dic.items(), key=lambda x:x[1], reverse=True) List 统计列表中重复项出现的次数 list1 = ['a','b','a','c','a','c','b'] from collections import Counter Counter(list1) Counter({'a': 3, 'b': 2, 'c': 2}) 来自 https://blog.csdn.net/angel20082008/article/details/51355921 二元组/字典数组排序 data = [(1, 'B'), (1, 'A'), (2, 'A'), (0, 'B'), (0, 'a')] #将x[1].lower()作为返回元组里的第一个元素,按照sorted的排序规律,就会先按字母排序,再按数字排序了 result = sorted(data,key=lambda x:(x[1].lower(),x[0])) print(result) #结果为 [(0, 'a'), (1, 'A'), (2, 'A'), (0, 'B'), (1, 'B')] data = [{'name': '张三', 'height': 175}, {'name': '李四', 'height': 165}, {'name': '王五', 'height': 185}] #将x['height']最为返回tuple的第个一元素 result = sorted(data,key=lambda x:(x['height'],x['name'])) print(result) #result 结果:[{'name': '李四', 'height': 165}, {'name': '张三', 'height': 175}, {'name': '王五', 'height': 185}] 来自 https://blog.csdn.net/qq_24076135/java/article/details/78550898 自定义排序 # sorted(nums, key=functools.cmp_to_key(mycmp)) 关键句 import functools class Solution: def minNumber(self, nums) -> str: def mycmp(a, b): if str(a)+str(b) > str(b)+str(a): return 1 return -1 ans = sorted(nums, key=functools.cmp_to_key(mycmp)) # print(ans) return \"\".join(str(x) for x in ans) list 标准库函数 list.append(obj) # 在列表末尾添加新的对象 list.count(obj) # 统计某个元素在列表中出现的次数 list.extend(seq) # 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） list.index(obj) # 从列表中找出某个值第一个匹配项的索引位置 list.insert(index, obj) # 将对象插入列表 list.pop([index=-1]) # 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 list.remove(obj) # 移除列表中某个值的第一个匹配项 list.reverse() # 反向列表中元素 list.sort(cmp=None, key=None, reverse=False) # 对原列表进行排序 list.index(obj,start,end) # 对象在列表中的索引号 list.count(obj) # 对象在列表中出现的总次数 Pandas 判断为nan if pd.isnull(table['0'][0]): 统计个数 df['id'].value_counts() 删除指定索引的 DataFrame.drop()中的参数labels是要删除的行或者列的名字，删除行还是列由参数axis控制，axis默认为0即按行删除，要想删除列只需令axis=1。 df.drop([2,'2018-01-01','a']) df.drop(['V'],axis=1) 库函数 Python标准库模块之heapq pip源 pip install -U XXX -i https://pypi.tuna.tsinghua.edu.cn/simple Jupyter 去掉警告 import warnings warnings.filterwarnings('ignore') 开启http服务器 python3 -m http.server 80 # 不加默认端口8000 爬虫 selenium + BeautifulSoup 实现的爬虫 开启一个浏览器 options = webdriver.ChromeOptions() # options.add_argument('--headless') 不显示浏览器 options.add_experimental_option('w3c', False) browser = webdriver.Chrome('chromedriver.exe的本地地址', options=options) url = \"http://baidu.com\" browser.get(url) 用beautifulSoup 解析页面 # 载入一个本地页面: path = './shuake/学生学习页面.html' htmlfile = open(path, 'r', encoding='utf-8') html = htmlfile.read() soup = BeautifulSoup(html, 'lxml') # 浏览器页面： html = browser.page_source soup = BeautifulSoup(html, 'lxml') 切换到frame与切回 # 切换到iframe里面点击播放视频 iframe = browser.find_elements_by_tag_name('iframe')[0] browser.switch_to.frame(iframe) browser.find_element_by_id('video').click() # 从frame中切回主文档 browser.switch_to.default_content() html = browser.page_source soup = BeautifulSoup(html, 'lxml') 模拟点击等操作 browser.find_element_by_id('video').click() # 不要在BeautifulSoup解析出的内容上调用click()等操作，应该用browser对象 BeautifulSoup解析元素内容 soup.find_all('div', attrs={'class': \"cells\"}) soup.find('span', attrs={'class': re.compile(r'roundpointStudent.*orange.*')}) "},"Python/数据库.html":{"url":"Python/数据库.html","title":"数据库","keywords":"","body":"数据库 Mysql 连接及操作 import pymysql # pip3 install PyMySQL # 打开数据库连接 db = pymysql.connect(\"10.199.245.40\",\"root\",\"123456\",\"vip_vdmp_bi\" ) # 使用 cursor() 方法创建一个游标对象 cursor cursor = db.cursor() # 使用 execute() 方法执行 SQL 查询 cursor.execute(\"show tables\") # 使用 fetchall() 方法获取所有数据. results = cursor.fetchall() for row in results: # 打印结果 print (row) # 使用 fetchone() 方法获取单条数据. # data = cursor.fetchone() # print (\"Database version : %s \" % data) # 关闭数据库连接 db.close() Spark Sql 查询sql from pyspark.sql import HiveContext, SQLContext from pyspark import SparkConf, SparkContext conf = SparkConf().setMaster(\"local\").setAppName(\"My App\") sc = SparkContext(conf = conf) sqlContext = SQLContext(sc) sql = \"select dt,*, oaid_cnt/all_cnt as OAID,imei_cnt/all_cnt as IMEI,null_cnt/all_cnt as NULL_id from hive_temp_advert.android_monitor_cnt where dt >= '20200628' and android_version = 'Android 7以下' ORDER BY dt DESC\" ans = sqlContext.sql(sql) ans.show() "},"前端/HTML.html":{"url":"前端/HTML.html","title":"HTML","keywords":"","body":"HTML 网页视频播放加速 谷歌浏览器按 f12,在 console 输入： document.querySelector('video').playbackRate = 3 "},"数据库/HiveSQL.html":{"url":"数据库/HiveSQL.html","title":"HiveSQL","keywords":"","body":"HiveSQL 基础操作 插入数据 insert into table hive_temp_advert.hzh_fot_test partition (dt = '20200607') values ('1', 'gg'); into必须，括号必须 一些技能 解析字段中的json数据 get_json_object(activity_property,'$.factory') -- 或者 -- `lateral view` 如： SELECT code, id, id_type, max(vers) as vers, max(hm) as hm from vipdw.ods_udp2usp_realtime_msg_kafkasource_5min t1 lateral view json_tuple(t1.message,'code','id','idType','version') t2 as code, id, id_type, vers where dt='${dt}' and t1.hm in (select MAX(hm) from vipdw.ods_udp2usp_realtime_msg_kafkasource_5min where dt='${dt}' limit 1) group by code, id, id_type "},"数据库/MySQL.html":{"url":"数据库/MySQL.html","title":"MySQL","keywords":"","body":"MySQL 增删改查 改 update UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值 ALTER TABLE 语句 ALTER TABLE 语句用于在已有的表中添加、修改或删除列。 如需在表中添加列，请使用下列语法: ALTER TABLE table_name ADD column_name datatype Hiev sql中有区别： ALTER TABLE hive_temp_advert.hzh_fot_test ADD COLUMNS (advertiser_type int comment '广告主类型'); 删 删除表中的列 ALTER TABLE table_name DROP COLUMN column_name 注释：某些数据库系统不允许这种在数据库表中删除列的方式 (DROP COLUMN column_name)。 要改变表中列的数据类型，请使用下列语法： ALTER TABLE table_name ALTER COLUMN column_name datatype 一些函数 时间转换函数 UNIX时间戳转换为日期用函数： FROM_UNIXTIME() select FROM_UNIXTIME(1156219870); 输出：2006-08-22 12:11:10 日期转换为UNIX时间戳用函数： UNIX_TIMESTAMP() Select UNIX_TIMESTAMP('2006-11-04 12:23:00'); 输出：1162614180 一些技能 mysql分组取最大(最小、最新、前N条)条记录 判断表中一个字段是否存在 select count(*) from information_schema.columns where table_name = '表名' and column_name = '字段名' Mybatis主键回写Model "},"数据库/Redis.html":{"url":"数据库/Redis.html","title":"Redis","keywords":"","body":"Redis 搭建Redis集群 Redis 集群搭建 遇到的一个坑：修改配置文件后直接使用redis-serve加载配置文件不会生效，需要用redis-cli进入后使用shutdown关闭，然后重新开启服务才会生效。也许是和redis的安装方式有关，这里用的是上面博客里写的源码编译安装。 "}}